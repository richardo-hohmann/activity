// Package activitystreams is a convenience wrapper around the raw ActivityStream vocabulary. This package is code-generated to permit more powerful expressions and manipulations of the ActivityStreams Vocabulary types. This package also does not permit use of 'unknown' properties, or those that are outside of the ActivityStream Vocabulary specification. However, it still correctly propagates them when repeatedly re-and-de-serialized. Custom extensions of the vocabulary are supported by modifying the data definitions in the generation tool and rerunning it. Do not modify this package directly.
package streams

import (
	"fmt"
	"github.com/go-fed/activity/vocab"
	"net/url"
	"time"
)

type Resolution int

const (
	Resolved Resolution = iota
	RawResolutionNeeded
	Unresolved
)

type Presence int

const (
	NoPresence Presence = iota
	ConvenientPresence
	RawPresence
)

// Resolver contains callback functions to execute when it Deserializes a raw map[string]interface{} into a concrete type. Clients can set only the callbacks they care about and handle the resulting concrete type.
type Resolver struct {
	// Callback function for the Object type
	ObjectCallback func(*Object) error
	// Callback function for the Link type
	LinkCallback func(*Link) error
	// Callback function for the Activity type
	ActivityCallback func(*Activity) error
	// Callback function for the IntransitiveActivity type
	IntransitiveActivityCallback func(*IntransitiveActivity) error
	// Callback function for the Collection type
	CollectionCallback func(*Collection) error
	// Callback function for the OrderedCollection type
	OrderedCollectionCallback func(*OrderedCollection) error
	// Callback function for the CollectionPage type
	CollectionPageCallback func(*CollectionPage) error
	// Callback function for the OrderedCollectionPage type
	OrderedCollectionPageCallback func(*OrderedCollectionPage) error
	// Callback function for the Accept type
	AcceptCallback func(*Accept) error
	// Callback function for the TentativeAccept type
	TentativeAcceptCallback func(*TentativeAccept) error
	// Callback function for the Add type
	AddCallback func(*Add) error
	// Callback function for the Arrive type
	ArriveCallback func(*Arrive) error
	// Callback function for the Create type
	CreateCallback func(*Create) error
	// Callback function for the Delete type
	DeleteCallback func(*Delete) error
	// Callback function for the Follow type
	FollowCallback func(*Follow) error
	// Callback function for the Ignore type
	IgnoreCallback func(*Ignore) error
	// Callback function for the Join type
	JoinCallback func(*Join) error
	// Callback function for the Leave type
	LeaveCallback func(*Leave) error
	// Callback function for the Like type
	LikeCallback func(*Like) error
	// Callback function for the Offer type
	OfferCallback func(*Offer) error
	// Callback function for the Invite type
	InviteCallback func(*Invite) error
	// Callback function for the Reject type
	RejectCallback func(*Reject) error
	// Callback function for the TentativeReject type
	TentativeRejectCallback func(*TentativeReject) error
	// Callback function for the Remove type
	RemoveCallback func(*Remove) error
	// Callback function for the Undo type
	UndoCallback func(*Undo) error
	// Callback function for the Update type
	UpdateCallback func(*Update) error
	// Callback function for the View type
	ViewCallback func(*View) error
	// Callback function for the Listen type
	ListenCallback func(*Listen) error
	// Callback function for the Read type
	ReadCallback func(*Read) error
	// Callback function for the Move type
	MoveCallback func(*Move) error
	// Callback function for the Travel type
	TravelCallback func(*Travel) error
	// Callback function for the Announce type
	AnnounceCallback func(*Announce) error
	// Callback function for the Block type
	BlockCallback func(*Block) error
	// Callback function for the Flag type
	FlagCallback func(*Flag) error
	// Callback function for the Dislike type
	DislikeCallback func(*Dislike) error
	// Callback function for the Question type
	QuestionCallback func(*Question) error
	// Callback function for the Application type
	ApplicationCallback func(*Application) error
	// Callback function for the Group type
	GroupCallback func(*Group) error
	// Callback function for the Organization type
	OrganizationCallback func(*Organization) error
	// Callback function for the Person type
	PersonCallback func(*Person) error
	// Callback function for the Service type
	ServiceCallback func(*Service) error
	// Callback function for the Relationship type
	RelationshipCallback func(*Relationship) error
	// Callback function for the Article type
	ArticleCallback func(*Article) error
	// Callback function for the Document type
	DocumentCallback func(*Document) error
	// Callback function for the Audio type
	AudioCallback func(*Audio) error
	// Callback function for the Image type
	ImageCallback func(*Image) error
	// Callback function for the Video type
	VideoCallback func(*Video) error
	// Callback function for the Note type
	NoteCallback func(*Note) error
	// Callback function for the Page type
	PageCallback func(*Page) error
	// Callback function for the Event type
	EventCallback func(*Event) error
	// Callback function for the Place type
	PlaceCallback func(*Place) error
	// Callback function for the Profile type
	ProfileCallback func(*Profile) error
	// Callback function for the Tombstone type
	TombstoneCallback func(*Tombstone) error
	// Callback function for the Mention type
	MentionCallback func(*Mention) error
}

// dispatch routes the given type to the appropriate Resolver callback.
func (t *Resolver) dispatch(i interface{}) (handled bool, err error) {
	// Begin generateResolver for type 'Object'
	if rawV, ok := i.(*vocab.Object); ok {
		if t.ObjectCallback != nil {
			v := &Object{raw: rawV}
			return true, t.ObjectCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Object'
	// Begin generateResolver for type 'Link'
	if rawV, ok := i.(*vocab.Link); ok {
		if t.LinkCallback != nil {
			v := &Link{raw: rawV}
			return true, t.LinkCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Link'
	// Begin generateResolver for type 'Activity'
	if rawV, ok := i.(*vocab.Activity); ok {
		if t.ActivityCallback != nil {
			v := &Activity{raw: rawV}
			return true, t.ActivityCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Activity'
	// Begin generateResolver for type 'IntransitiveActivity'
	if rawV, ok := i.(*vocab.IntransitiveActivity); ok {
		if t.IntransitiveActivityCallback != nil {
			v := &IntransitiveActivity{raw: rawV}
			return true, t.IntransitiveActivityCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'IntransitiveActivity'
	// Begin generateResolver for type 'Collection'
	if rawV, ok := i.(*vocab.Collection); ok {
		if t.CollectionCallback != nil {
			v := &Collection{raw: rawV}
			return true, t.CollectionCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Collection'
	// Begin generateResolver for type 'OrderedCollection'
	if rawV, ok := i.(*vocab.OrderedCollection); ok {
		if t.OrderedCollectionCallback != nil {
			v := &OrderedCollection{raw: rawV}
			return true, t.OrderedCollectionCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'OrderedCollection'
	// Begin generateResolver for type 'CollectionPage'
	if rawV, ok := i.(*vocab.CollectionPage); ok {
		if t.CollectionPageCallback != nil {
			v := &CollectionPage{raw: rawV}
			return true, t.CollectionPageCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'CollectionPage'
	// Begin generateResolver for type 'OrderedCollectionPage'
	if rawV, ok := i.(*vocab.OrderedCollectionPage); ok {
		if t.OrderedCollectionPageCallback != nil {
			v := &OrderedCollectionPage{raw: rawV}
			return true, t.OrderedCollectionPageCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'OrderedCollectionPage'
	// Begin generateResolver for type 'Accept'
	if rawV, ok := i.(*vocab.Accept); ok {
		if t.AcceptCallback != nil {
			v := &Accept{raw: rawV}
			return true, t.AcceptCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Accept'
	// Begin generateResolver for type 'TentativeAccept'
	if rawV, ok := i.(*vocab.TentativeAccept); ok {
		if t.TentativeAcceptCallback != nil {
			v := &TentativeAccept{raw: rawV}
			return true, t.TentativeAcceptCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'TentativeAccept'
	// Begin generateResolver for type 'Add'
	if rawV, ok := i.(*vocab.Add); ok {
		if t.AddCallback != nil {
			v := &Add{raw: rawV}
			return true, t.AddCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Add'
	// Begin generateResolver for type 'Arrive'
	if rawV, ok := i.(*vocab.Arrive); ok {
		if t.ArriveCallback != nil {
			v := &Arrive{raw: rawV}
			return true, t.ArriveCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Arrive'
	// Begin generateResolver for type 'Create'
	if rawV, ok := i.(*vocab.Create); ok {
		if t.CreateCallback != nil {
			v := &Create{raw: rawV}
			return true, t.CreateCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Create'
	// Begin generateResolver for type 'Delete'
	if rawV, ok := i.(*vocab.Delete); ok {
		if t.DeleteCallback != nil {
			v := &Delete{raw: rawV}
			return true, t.DeleteCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Delete'
	// Begin generateResolver for type 'Follow'
	if rawV, ok := i.(*vocab.Follow); ok {
		if t.FollowCallback != nil {
			v := &Follow{raw: rawV}
			return true, t.FollowCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Follow'
	// Begin generateResolver for type 'Ignore'
	if rawV, ok := i.(*vocab.Ignore); ok {
		if t.IgnoreCallback != nil {
			v := &Ignore{raw: rawV}
			return true, t.IgnoreCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Ignore'
	// Begin generateResolver for type 'Join'
	if rawV, ok := i.(*vocab.Join); ok {
		if t.JoinCallback != nil {
			v := &Join{raw: rawV}
			return true, t.JoinCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Join'
	// Begin generateResolver for type 'Leave'
	if rawV, ok := i.(*vocab.Leave); ok {
		if t.LeaveCallback != nil {
			v := &Leave{raw: rawV}
			return true, t.LeaveCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Leave'
	// Begin generateResolver for type 'Like'
	if rawV, ok := i.(*vocab.Like); ok {
		if t.LikeCallback != nil {
			v := &Like{raw: rawV}
			return true, t.LikeCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Like'
	// Begin generateResolver for type 'Offer'
	if rawV, ok := i.(*vocab.Offer); ok {
		if t.OfferCallback != nil {
			v := &Offer{raw: rawV}
			return true, t.OfferCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Offer'
	// Begin generateResolver for type 'Invite'
	if rawV, ok := i.(*vocab.Invite); ok {
		if t.InviteCallback != nil {
			v := &Invite{raw: rawV}
			return true, t.InviteCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Invite'
	// Begin generateResolver for type 'Reject'
	if rawV, ok := i.(*vocab.Reject); ok {
		if t.RejectCallback != nil {
			v := &Reject{raw: rawV}
			return true, t.RejectCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Reject'
	// Begin generateResolver for type 'TentativeReject'
	if rawV, ok := i.(*vocab.TentativeReject); ok {
		if t.TentativeRejectCallback != nil {
			v := &TentativeReject{raw: rawV}
			return true, t.TentativeRejectCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'TentativeReject'
	// Begin generateResolver for type 'Remove'
	if rawV, ok := i.(*vocab.Remove); ok {
		if t.RemoveCallback != nil {
			v := &Remove{raw: rawV}
			return true, t.RemoveCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Remove'
	// Begin generateResolver for type 'Undo'
	if rawV, ok := i.(*vocab.Undo); ok {
		if t.UndoCallback != nil {
			v := &Undo{raw: rawV}
			return true, t.UndoCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Undo'
	// Begin generateResolver for type 'Update'
	if rawV, ok := i.(*vocab.Update); ok {
		if t.UpdateCallback != nil {
			v := &Update{raw: rawV}
			return true, t.UpdateCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Update'
	// Begin generateResolver for type 'View'
	if rawV, ok := i.(*vocab.View); ok {
		if t.ViewCallback != nil {
			v := &View{raw: rawV}
			return true, t.ViewCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'View'
	// Begin generateResolver for type 'Listen'
	if rawV, ok := i.(*vocab.Listen); ok {
		if t.ListenCallback != nil {
			v := &Listen{raw: rawV}
			return true, t.ListenCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Listen'
	// Begin generateResolver for type 'Read'
	if rawV, ok := i.(*vocab.Read); ok {
		if t.ReadCallback != nil {
			v := &Read{raw: rawV}
			return true, t.ReadCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Read'
	// Begin generateResolver for type 'Move'
	if rawV, ok := i.(*vocab.Move); ok {
		if t.MoveCallback != nil {
			v := &Move{raw: rawV}
			return true, t.MoveCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Move'
	// Begin generateResolver for type 'Travel'
	if rawV, ok := i.(*vocab.Travel); ok {
		if t.TravelCallback != nil {
			v := &Travel{raw: rawV}
			return true, t.TravelCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Travel'
	// Begin generateResolver for type 'Announce'
	if rawV, ok := i.(*vocab.Announce); ok {
		if t.AnnounceCallback != nil {
			v := &Announce{raw: rawV}
			return true, t.AnnounceCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Announce'
	// Begin generateResolver for type 'Block'
	if rawV, ok := i.(*vocab.Block); ok {
		if t.BlockCallback != nil {
			v := &Block{raw: rawV}
			return true, t.BlockCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Block'
	// Begin generateResolver for type 'Flag'
	if rawV, ok := i.(*vocab.Flag); ok {
		if t.FlagCallback != nil {
			v := &Flag{raw: rawV}
			return true, t.FlagCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Flag'
	// Begin generateResolver for type 'Dislike'
	if rawV, ok := i.(*vocab.Dislike); ok {
		if t.DislikeCallback != nil {
			v := &Dislike{raw: rawV}
			return true, t.DislikeCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Dislike'
	// Begin generateResolver for type 'Question'
	if rawV, ok := i.(*vocab.Question); ok {
		if t.QuestionCallback != nil {
			v := &Question{raw: rawV}
			return true, t.QuestionCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Question'
	// Begin generateResolver for type 'Application'
	if rawV, ok := i.(*vocab.Application); ok {
		if t.ApplicationCallback != nil {
			v := &Application{raw: rawV}
			return true, t.ApplicationCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Application'
	// Begin generateResolver for type 'Group'
	if rawV, ok := i.(*vocab.Group); ok {
		if t.GroupCallback != nil {
			v := &Group{raw: rawV}
			return true, t.GroupCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Group'
	// Begin generateResolver for type 'Organization'
	if rawV, ok := i.(*vocab.Organization); ok {
		if t.OrganizationCallback != nil {
			v := &Organization{raw: rawV}
			return true, t.OrganizationCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Organization'
	// Begin generateResolver for type 'Person'
	if rawV, ok := i.(*vocab.Person); ok {
		if t.PersonCallback != nil {
			v := &Person{raw: rawV}
			return true, t.PersonCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Person'
	// Begin generateResolver for type 'Service'
	if rawV, ok := i.(*vocab.Service); ok {
		if t.ServiceCallback != nil {
			v := &Service{raw: rawV}
			return true, t.ServiceCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Service'
	// Begin generateResolver for type 'Relationship'
	if rawV, ok := i.(*vocab.Relationship); ok {
		if t.RelationshipCallback != nil {
			v := &Relationship{raw: rawV}
			return true, t.RelationshipCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Relationship'
	// Begin generateResolver for type 'Article'
	if rawV, ok := i.(*vocab.Article); ok {
		if t.ArticleCallback != nil {
			v := &Article{raw: rawV}
			return true, t.ArticleCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Article'
	// Begin generateResolver for type 'Document'
	if rawV, ok := i.(*vocab.Document); ok {
		if t.DocumentCallback != nil {
			v := &Document{raw: rawV}
			return true, t.DocumentCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Document'
	// Begin generateResolver for type 'Audio'
	if rawV, ok := i.(*vocab.Audio); ok {
		if t.AudioCallback != nil {
			v := &Audio{raw: rawV}
			return true, t.AudioCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Audio'
	// Begin generateResolver for type 'Image'
	if rawV, ok := i.(*vocab.Image); ok {
		if t.ImageCallback != nil {
			v := &Image{raw: rawV}
			return true, t.ImageCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Image'
	// Begin generateResolver for type 'Video'
	if rawV, ok := i.(*vocab.Video); ok {
		if t.VideoCallback != nil {
			v := &Video{raw: rawV}
			return true, t.VideoCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Video'
	// Begin generateResolver for type 'Note'
	if rawV, ok := i.(*vocab.Note); ok {
		if t.NoteCallback != nil {
			v := &Note{raw: rawV}
			return true, t.NoteCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Note'
	// Begin generateResolver for type 'Page'
	if rawV, ok := i.(*vocab.Page); ok {
		if t.PageCallback != nil {
			v := &Page{raw: rawV}
			return true, t.PageCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Page'
	// Begin generateResolver for type 'Event'
	if rawV, ok := i.(*vocab.Event); ok {
		if t.EventCallback != nil {
			v := &Event{raw: rawV}
			return true, t.EventCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Event'
	// Begin generateResolver for type 'Place'
	if rawV, ok := i.(*vocab.Place); ok {
		if t.PlaceCallback != nil {
			v := &Place{raw: rawV}
			return true, t.PlaceCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Place'
	// Begin generateResolver for type 'Profile'
	if rawV, ok := i.(*vocab.Profile); ok {
		if t.ProfileCallback != nil {
			v := &Profile{raw: rawV}
			return true, t.ProfileCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Profile'
	// Begin generateResolver for type 'Tombstone'
	if rawV, ok := i.(*vocab.Tombstone); ok {
		if t.TombstoneCallback != nil {
			v := &Tombstone{raw: rawV}
			return true, t.TombstoneCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Tombstone'
	// Begin generateResolver for type 'Mention'
	if rawV, ok := i.(*vocab.Mention); ok {
		if t.MentionCallback != nil {
			v := &Mention{raw: rawV}
			return true, t.MentionCallback(v)
		} else {
			return false, nil
		}
	}
	// End generateResolver for type 'Mention'
	return false, fmt.Errorf("The interface did not match any known types: %T", i)

}

// Determines which concrete type to deserialize this json-unmarshalled item into, returning an error if it cannot determine which type to deserialize into. The appropriate callback, if present, will then be invoked with the concrete deserialized type. If the callback function returns an error, it is passed back through Deserialize.
func (t *Resolver) Deserialize(m map[string]interface{}) (err error) {
	var typeStringVals []string
	typeInterface, ok := m["type"]
	if !ok {
		return fmt.Errorf("Cannot determine type: missing 'type' property")
	}
	if typeStr, ok := typeInterface.(string); ok {
		typeStringVals = append(typeStringVals, typeStr)
	} else if typeSlice, ok := typeInterface.([]interface{}); ok {
		for _, elem := range typeSlice {
			if typeStr, ok := elem.(string); ok {
				typeStringVals = append(typeStringVals, typeStr)
			}
		}
		if len(typeStringVals) == 0 {
			return fmt.Errorf("Cannot determine type: 'type' property is []interface{} with no string elements: %+v", typeInterface)
		}
	} else {
		return fmt.Errorf("Cannot determine type: 'type' property is not string nor []interface{}: %T", typeInterface)
	}
	// Begin generateResolver for type 'Object'
	for _, typeName := range typeStringVals {
		if typeName == "Object" {
			if t.ObjectCallback != nil {
				v := &vocab.Object{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Object{v}
				return t.ObjectCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Object'
	// Begin generateResolver for type 'Link'
	for _, typeName := range typeStringVals {
		if typeName == "Link" {
			if t.LinkCallback != nil {
				v := &vocab.Link{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Link{v}
				return t.LinkCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Link'
	// Begin generateResolver for type 'Activity'
	for _, typeName := range typeStringVals {
		if typeName == "Activity" {
			if t.ActivityCallback != nil {
				v := &vocab.Activity{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Activity{v}
				return t.ActivityCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Activity'
	// Begin generateResolver for type 'IntransitiveActivity'
	for _, typeName := range typeStringVals {
		if typeName == "IntransitiveActivity" {
			if t.IntransitiveActivityCallback != nil {
				v := &vocab.IntransitiveActivity{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &IntransitiveActivity{v}
				return t.IntransitiveActivityCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'IntransitiveActivity'
	// Begin generateResolver for type 'Collection'
	for _, typeName := range typeStringVals {
		if typeName == "Collection" {
			if t.CollectionCallback != nil {
				v := &vocab.Collection{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Collection{v}
				return t.CollectionCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Collection'
	// Begin generateResolver for type 'OrderedCollection'
	for _, typeName := range typeStringVals {
		if typeName == "OrderedCollection" {
			if t.OrderedCollectionCallback != nil {
				v := &vocab.OrderedCollection{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &OrderedCollection{v}
				return t.OrderedCollectionCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'OrderedCollection'
	// Begin generateResolver for type 'CollectionPage'
	for _, typeName := range typeStringVals {
		if typeName == "CollectionPage" {
			if t.CollectionPageCallback != nil {
				v := &vocab.CollectionPage{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &CollectionPage{v}
				return t.CollectionPageCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'CollectionPage'
	// Begin generateResolver for type 'OrderedCollectionPage'
	for _, typeName := range typeStringVals {
		if typeName == "OrderedCollectionPage" {
			if t.OrderedCollectionPageCallback != nil {
				v := &vocab.OrderedCollectionPage{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &OrderedCollectionPage{v}
				return t.OrderedCollectionPageCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'OrderedCollectionPage'
	// Begin generateResolver for type 'Accept'
	for _, typeName := range typeStringVals {
		if typeName == "Accept" {
			if t.AcceptCallback != nil {
				v := &vocab.Accept{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Accept{v}
				return t.AcceptCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Accept'
	// Begin generateResolver for type 'TentativeAccept'
	for _, typeName := range typeStringVals {
		if typeName == "TentativeAccept" {
			if t.TentativeAcceptCallback != nil {
				v := &vocab.TentativeAccept{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &TentativeAccept{v}
				return t.TentativeAcceptCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'TentativeAccept'
	// Begin generateResolver for type 'Add'
	for _, typeName := range typeStringVals {
		if typeName == "Add" {
			if t.AddCallback != nil {
				v := &vocab.Add{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Add{v}
				return t.AddCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Add'
	// Begin generateResolver for type 'Arrive'
	for _, typeName := range typeStringVals {
		if typeName == "Arrive" {
			if t.ArriveCallback != nil {
				v := &vocab.Arrive{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Arrive{v}
				return t.ArriveCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Arrive'
	// Begin generateResolver for type 'Create'
	for _, typeName := range typeStringVals {
		if typeName == "Create" {
			if t.CreateCallback != nil {
				v := &vocab.Create{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Create{v}
				return t.CreateCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Create'
	// Begin generateResolver for type 'Delete'
	for _, typeName := range typeStringVals {
		if typeName == "Delete" {
			if t.DeleteCallback != nil {
				v := &vocab.Delete{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Delete{v}
				return t.DeleteCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Delete'
	// Begin generateResolver for type 'Follow'
	for _, typeName := range typeStringVals {
		if typeName == "Follow" {
			if t.FollowCallback != nil {
				v := &vocab.Follow{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Follow{v}
				return t.FollowCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Follow'
	// Begin generateResolver for type 'Ignore'
	for _, typeName := range typeStringVals {
		if typeName == "Ignore" {
			if t.IgnoreCallback != nil {
				v := &vocab.Ignore{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Ignore{v}
				return t.IgnoreCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Ignore'
	// Begin generateResolver for type 'Join'
	for _, typeName := range typeStringVals {
		if typeName == "Join" {
			if t.JoinCallback != nil {
				v := &vocab.Join{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Join{v}
				return t.JoinCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Join'
	// Begin generateResolver for type 'Leave'
	for _, typeName := range typeStringVals {
		if typeName == "Leave" {
			if t.LeaveCallback != nil {
				v := &vocab.Leave{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Leave{v}
				return t.LeaveCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Leave'
	// Begin generateResolver for type 'Like'
	for _, typeName := range typeStringVals {
		if typeName == "Like" {
			if t.LikeCallback != nil {
				v := &vocab.Like{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Like{v}
				return t.LikeCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Like'
	// Begin generateResolver for type 'Offer'
	for _, typeName := range typeStringVals {
		if typeName == "Offer" {
			if t.OfferCallback != nil {
				v := &vocab.Offer{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Offer{v}
				return t.OfferCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Offer'
	// Begin generateResolver for type 'Invite'
	for _, typeName := range typeStringVals {
		if typeName == "Invite" {
			if t.InviteCallback != nil {
				v := &vocab.Invite{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Invite{v}
				return t.InviteCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Invite'
	// Begin generateResolver for type 'Reject'
	for _, typeName := range typeStringVals {
		if typeName == "Reject" {
			if t.RejectCallback != nil {
				v := &vocab.Reject{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Reject{v}
				return t.RejectCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Reject'
	// Begin generateResolver for type 'TentativeReject'
	for _, typeName := range typeStringVals {
		if typeName == "TentativeReject" {
			if t.TentativeRejectCallback != nil {
				v := &vocab.TentativeReject{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &TentativeReject{v}
				return t.TentativeRejectCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'TentativeReject'
	// Begin generateResolver for type 'Remove'
	for _, typeName := range typeStringVals {
		if typeName == "Remove" {
			if t.RemoveCallback != nil {
				v := &vocab.Remove{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Remove{v}
				return t.RemoveCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Remove'
	// Begin generateResolver for type 'Undo'
	for _, typeName := range typeStringVals {
		if typeName == "Undo" {
			if t.UndoCallback != nil {
				v := &vocab.Undo{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Undo{v}
				return t.UndoCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Undo'
	// Begin generateResolver for type 'Update'
	for _, typeName := range typeStringVals {
		if typeName == "Update" {
			if t.UpdateCallback != nil {
				v := &vocab.Update{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Update{v}
				return t.UpdateCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Update'
	// Begin generateResolver for type 'View'
	for _, typeName := range typeStringVals {
		if typeName == "View" {
			if t.ViewCallback != nil {
				v := &vocab.View{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &View{v}
				return t.ViewCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'View'
	// Begin generateResolver for type 'Listen'
	for _, typeName := range typeStringVals {
		if typeName == "Listen" {
			if t.ListenCallback != nil {
				v := &vocab.Listen{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Listen{v}
				return t.ListenCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Listen'
	// Begin generateResolver for type 'Read'
	for _, typeName := range typeStringVals {
		if typeName == "Read" {
			if t.ReadCallback != nil {
				v := &vocab.Read{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Read{v}
				return t.ReadCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Read'
	// Begin generateResolver for type 'Move'
	for _, typeName := range typeStringVals {
		if typeName == "Move" {
			if t.MoveCallback != nil {
				v := &vocab.Move{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Move{v}
				return t.MoveCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Move'
	// Begin generateResolver for type 'Travel'
	for _, typeName := range typeStringVals {
		if typeName == "Travel" {
			if t.TravelCallback != nil {
				v := &vocab.Travel{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Travel{v}
				return t.TravelCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Travel'
	// Begin generateResolver for type 'Announce'
	for _, typeName := range typeStringVals {
		if typeName == "Announce" {
			if t.AnnounceCallback != nil {
				v := &vocab.Announce{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Announce{v}
				return t.AnnounceCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Announce'
	// Begin generateResolver for type 'Block'
	for _, typeName := range typeStringVals {
		if typeName == "Block" {
			if t.BlockCallback != nil {
				v := &vocab.Block{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Block{v}
				return t.BlockCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Block'
	// Begin generateResolver for type 'Flag'
	for _, typeName := range typeStringVals {
		if typeName == "Flag" {
			if t.FlagCallback != nil {
				v := &vocab.Flag{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Flag{v}
				return t.FlagCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Flag'
	// Begin generateResolver for type 'Dislike'
	for _, typeName := range typeStringVals {
		if typeName == "Dislike" {
			if t.DislikeCallback != nil {
				v := &vocab.Dislike{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Dislike{v}
				return t.DislikeCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Dislike'
	// Begin generateResolver for type 'Question'
	for _, typeName := range typeStringVals {
		if typeName == "Question" {
			if t.QuestionCallback != nil {
				v := &vocab.Question{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Question{v}
				return t.QuestionCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Question'
	// Begin generateResolver for type 'Application'
	for _, typeName := range typeStringVals {
		if typeName == "Application" {
			if t.ApplicationCallback != nil {
				v := &vocab.Application{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Application{v}
				return t.ApplicationCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Application'
	// Begin generateResolver for type 'Group'
	for _, typeName := range typeStringVals {
		if typeName == "Group" {
			if t.GroupCallback != nil {
				v := &vocab.Group{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Group{v}
				return t.GroupCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Group'
	// Begin generateResolver for type 'Organization'
	for _, typeName := range typeStringVals {
		if typeName == "Organization" {
			if t.OrganizationCallback != nil {
				v := &vocab.Organization{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Organization{v}
				return t.OrganizationCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Organization'
	// Begin generateResolver for type 'Person'
	for _, typeName := range typeStringVals {
		if typeName == "Person" {
			if t.PersonCallback != nil {
				v := &vocab.Person{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Person{v}
				return t.PersonCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Person'
	// Begin generateResolver for type 'Service'
	for _, typeName := range typeStringVals {
		if typeName == "Service" {
			if t.ServiceCallback != nil {
				v := &vocab.Service{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Service{v}
				return t.ServiceCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Service'
	// Begin generateResolver for type 'Relationship'
	for _, typeName := range typeStringVals {
		if typeName == "Relationship" {
			if t.RelationshipCallback != nil {
				v := &vocab.Relationship{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Relationship{v}
				return t.RelationshipCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Relationship'
	// Begin generateResolver for type 'Article'
	for _, typeName := range typeStringVals {
		if typeName == "Article" {
			if t.ArticleCallback != nil {
				v := &vocab.Article{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Article{v}
				return t.ArticleCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Article'
	// Begin generateResolver for type 'Document'
	for _, typeName := range typeStringVals {
		if typeName == "Document" {
			if t.DocumentCallback != nil {
				v := &vocab.Document{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Document{v}
				return t.DocumentCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Document'
	// Begin generateResolver for type 'Audio'
	for _, typeName := range typeStringVals {
		if typeName == "Audio" {
			if t.AudioCallback != nil {
				v := &vocab.Audio{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Audio{v}
				return t.AudioCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Audio'
	// Begin generateResolver for type 'Image'
	for _, typeName := range typeStringVals {
		if typeName == "Image" {
			if t.ImageCallback != nil {
				v := &vocab.Image{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Image{v}
				return t.ImageCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Image'
	// Begin generateResolver for type 'Video'
	for _, typeName := range typeStringVals {
		if typeName == "Video" {
			if t.VideoCallback != nil {
				v := &vocab.Video{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Video{v}
				return t.VideoCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Video'
	// Begin generateResolver for type 'Note'
	for _, typeName := range typeStringVals {
		if typeName == "Note" {
			if t.NoteCallback != nil {
				v := &vocab.Note{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Note{v}
				return t.NoteCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Note'
	// Begin generateResolver for type 'Page'
	for _, typeName := range typeStringVals {
		if typeName == "Page" {
			if t.PageCallback != nil {
				v := &vocab.Page{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Page{v}
				return t.PageCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Page'
	// Begin generateResolver for type 'Event'
	for _, typeName := range typeStringVals {
		if typeName == "Event" {
			if t.EventCallback != nil {
				v := &vocab.Event{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Event{v}
				return t.EventCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Event'
	// Begin generateResolver for type 'Place'
	for _, typeName := range typeStringVals {
		if typeName == "Place" {
			if t.PlaceCallback != nil {
				v := &vocab.Place{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Place{v}
				return t.PlaceCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Place'
	// Begin generateResolver for type 'Profile'
	for _, typeName := range typeStringVals {
		if typeName == "Profile" {
			if t.ProfileCallback != nil {
				v := &vocab.Profile{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Profile{v}
				return t.ProfileCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Profile'
	// Begin generateResolver for type 'Tombstone'
	for _, typeName := range typeStringVals {
		if typeName == "Tombstone" {
			if t.TombstoneCallback != nil {
				v := &vocab.Tombstone{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Tombstone{v}
				return t.TombstoneCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Tombstone'
	// Begin generateResolver for type 'Mention'
	for _, typeName := range typeStringVals {
		if typeName == "Mention" {
			if t.MentionCallback != nil {
				v := &vocab.Mention{}
				if err := v.Deserialize(m); err != nil {
					return err
				}
				as := &Mention{v}
				return t.MentionCallback(as)
			} else {
				return nil
			}
		}
	}
	// End generateResolver for type 'Mention'
	return fmt.Errorf("The 'type' property did not match any known types: %+v", typeStringVals)

}

// Describes an object of any kind. The Object type serves as the base type for most of the other kinds of objects defined in the Activity Vocabulary, including other Core types such as Activity, IntransitiveActivity, Collection and OrderedCollection. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Object struct {
	// The raw type from the vocab package
	raw *vocab.Object
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Object) Raw() (n *vocab.Object) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Object) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Object) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Object) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Object) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Object) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Object) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Object) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Object) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Object) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Object) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Object) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Object) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Object) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Object) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Object) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Object) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Object) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Object) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Object) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Object) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Object) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Object) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Object) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Object) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Object) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Object) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Object) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Object) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Object) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Object) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Object) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Object) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Object) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Object) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Object) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Object) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Object) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Object) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Object) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Object) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Object) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Object) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Object) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Object) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Object) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Object) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Object) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Object) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Object) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Object) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Object) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Object) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Object) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Object) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Object) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Object) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Object) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Object) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Object) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Object) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Object) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Object) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Object) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Object) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Object) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Object) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Object) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Object) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Object) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Object) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Object) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Object) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Object) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Object) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Object) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Object) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Object) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Object) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Object) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Object) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Object) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Object) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Object) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Object) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Object) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Object) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Object) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Object) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Object) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Object) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Object) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Object) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Object) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Object) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Object) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Object) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Object) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Object) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Object) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Object) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Object) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A Link is an indirect, qualified reference to a resource identified by a URL. The fundamental model for links is established by [ RFC5988]. Many of the properties defined by the Activity Vocabulary allow values that are either instances of Object or Link. When a Link is used, it establishes a qualified relation connecting the subject (the containing object) to the resource identified by the href. Properties of the Link are properties of the reference as opposed to properties of the resource. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Link struct {
	// The raw type from the vocab package
	raw *vocab.Link
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Link) Raw() (n *vocab.Link) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Link) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Link) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Link) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Link) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// GetHref attempts to get this 'href' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetHref() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasHref() {
		k = t.raw.GetHref()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasHref returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasHref() (p Presence) {
	p = NoPresence
	if t.raw.HasHref() {
		p = ConvenientPresence
	}
	return

}

// SetHref sets the value for property 'href'.
func (t *Link) SetHref(k url.URL) {
	t.raw.SetHref(k)

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Link) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenRel returns the number of values this property contains. Each index be used with HasRel to determine if GetRel is safe to call or if raw handling would be needed.%!(EXTRA string=rel)
func (t *Link) LenRel() (idx int) {
	return t.raw.RelLen()

}

// GetRel attempts to get this 'rel' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetRel(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsRel(idx) {
		k = t.raw.GetRel(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsRelIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddRel appends the value for property 'rel'.
func (t *Link) AddRel(k string) {
	t.raw.AddRel(k)

}

// RemoveRel deletes the value from the specified index for property 'rel'.
func (t *Link) RemoveRel(idx int) {
	t.raw.RemoveRel(idx)

}

// HasRel returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasRel(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsRel(idx) {
		p = ConvenientPresence
	} else if t.raw.IsRelIRI(idx) {
		p = RawPresence
	}
	return

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Link) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Link) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Link) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Link) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Link) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Link) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Link) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Link) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Link) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Link) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Link) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Link) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Link) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Link) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Link) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Link) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// GetHreflang attempts to get this 'hreflang' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetHreflang() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsHreflang() {
		k = t.raw.GetHreflang()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsHreflangIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasHreflang returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasHreflang() (p Presence) {
	p = NoPresence
	if t.raw.IsHreflang() {
		p = ConvenientPresence
	} else if t.raw.IsHreflangIRI() {
		p = RawPresence
	}
	return

}

// SetHreflang sets the value for property 'hreflang'.
func (t *Link) SetHreflang(k string) {
	t.raw.SetHreflang(k)

}

// GetHeight attempts to get this 'height' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetHeight() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsHeight() {
		k = t.raw.GetHeight()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsHeightIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasHeight returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasHeight() (p Presence) {
	p = NoPresence
	if t.raw.IsHeight() {
		p = ConvenientPresence
	} else if t.raw.IsHeightIRI() {
		p = RawPresence
	}
	return

}

// SetHeight sets the value for property 'height'.
func (t *Link) SetHeight(k int64) {
	t.raw.SetHeight(k)

}

// GetWidth attempts to get this 'width' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Link) GetWidth() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsWidth() {
		k = t.raw.GetWidth()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsWidthIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasWidth returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasWidth() (p Presence) {
	p = NoPresence
	if t.raw.IsWidth() {
		p = ConvenientPresence
	} else if t.raw.IsWidthIRI() {
		p = RawPresence
	}
	return

}

// SetWidth sets the value for property 'width'.
func (t *Link) SetWidth(k int64) {
	t.raw.SetWidth(k)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Link) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Link) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Link) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Link) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// An Activity is a subtype of Object that describes some form of action that may happen, is currently happening, or has already happened. The Activity type itself serves as an abstract base type for all types of activities. It is important to note that the Activity type itself does not carry any specific semantics about the kind of action being taken. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Activity struct {
	// The raw type from the vocab package
	raw *vocab.Activity
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Activity) Raw() (n *vocab.Activity) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Activity) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Activity) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Activity) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Activity) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Activity) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Activity) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Activity) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Activity) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Activity) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Activity) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Activity) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Activity) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Activity) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Activity) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Activity) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Activity) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Activity) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Activity) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Activity) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Activity) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Activity) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Activity) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Activity) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Activity) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Activity) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Activity) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Activity) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Activity) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Activity) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Activity) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Activity) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Activity) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Activity) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Activity) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Activity) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Activity) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Activity) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Activity) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Activity) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Activity) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Activity) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Activity) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Activity) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Activity) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Activity) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Activity) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Activity) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Activity) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Activity) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Activity) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Activity) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Activity) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Activity) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Activity) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Activity) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Activity) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Activity) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Activity) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Activity) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Activity) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Activity) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Activity) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Activity) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Activity) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Activity) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Activity) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Activity) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Activity) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Activity) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Activity) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Activity) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Activity) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Activity) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Activity) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Activity) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Activity) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Activity) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Activity) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Activity) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Activity) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Activity) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Activity) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Activity) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Activity) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Activity) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Activity) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Activity) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Activity) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Activity) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Activity) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Activity) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Activity) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Activity) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Activity) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Activity) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Activity) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Activity) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Activity) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Activity) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Activity) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Activity) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Activity) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Activity) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Activity) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Activity) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Activity) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Activity) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Activity) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Activity) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Activity) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Activity) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Activity) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Activity) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Activity) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Activity) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Activity) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Activity) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Activity) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Activity) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Instances of IntransitiveActivity are a subtype of Activity representing intransitive actions. The object property is therefore inappropriate for these activities. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type IntransitiveActivity struct {
	// The raw type from the vocab package
	raw *vocab.IntransitiveActivity
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *IntransitiveActivity) Raw() (n *vocab.IntransitiveActivity) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *IntransitiveActivity) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *IntransitiveActivity) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *IntransitiveActivity) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *IntransitiveActivity) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *IntransitiveActivity) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *IntransitiveActivity) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *IntransitiveActivity) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *IntransitiveActivity) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *IntransitiveActivity) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *IntransitiveActivity) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *IntransitiveActivity) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *IntransitiveActivity) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *IntransitiveActivity) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *IntransitiveActivity) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *IntransitiveActivity) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *IntransitiveActivity) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *IntransitiveActivity) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *IntransitiveActivity) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *IntransitiveActivity) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *IntransitiveActivity) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *IntransitiveActivity) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *IntransitiveActivity) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *IntransitiveActivity) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *IntransitiveActivity) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *IntransitiveActivity) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *IntransitiveActivity) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *IntransitiveActivity) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *IntransitiveActivity) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *IntransitiveActivity) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *IntransitiveActivity) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *IntransitiveActivity) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *IntransitiveActivity) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *IntransitiveActivity) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *IntransitiveActivity) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *IntransitiveActivity) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *IntransitiveActivity) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *IntransitiveActivity) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *IntransitiveActivity) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *IntransitiveActivity) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *IntransitiveActivity) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *IntransitiveActivity) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *IntransitiveActivity) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *IntransitiveActivity) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *IntransitiveActivity) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *IntransitiveActivity) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *IntransitiveActivity) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *IntransitiveActivity) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *IntransitiveActivity) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *IntransitiveActivity) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *IntransitiveActivity) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *IntransitiveActivity) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *IntransitiveActivity) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *IntransitiveActivity) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *IntransitiveActivity) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *IntransitiveActivity) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *IntransitiveActivity) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *IntransitiveActivity) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *IntransitiveActivity) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *IntransitiveActivity) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *IntransitiveActivity) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *IntransitiveActivity) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *IntransitiveActivity) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *IntransitiveActivity) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *IntransitiveActivity) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *IntransitiveActivity) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *IntransitiveActivity) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *IntransitiveActivity) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *IntransitiveActivity) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *IntransitiveActivity) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *IntransitiveActivity) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *IntransitiveActivity) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *IntransitiveActivity) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *IntransitiveActivity) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *IntransitiveActivity) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *IntransitiveActivity) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *IntransitiveActivity) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *IntransitiveActivity) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *IntransitiveActivity) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *IntransitiveActivity) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *IntransitiveActivity) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *IntransitiveActivity) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *IntransitiveActivity) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *IntransitiveActivity) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *IntransitiveActivity) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *IntransitiveActivity) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *IntransitiveActivity) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *IntransitiveActivity) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *IntransitiveActivity) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *IntransitiveActivity) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *IntransitiveActivity) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *IntransitiveActivity) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *IntransitiveActivity) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *IntransitiveActivity) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *IntransitiveActivity) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *IntransitiveActivity) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *IntransitiveActivity) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *IntransitiveActivity) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *IntransitiveActivity) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *IntransitiveActivity) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *IntransitiveActivity) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *IntransitiveActivity) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *IntransitiveActivity) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *IntransitiveActivity) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *IntransitiveActivity) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *IntransitiveActivity) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *IntransitiveActivity) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *IntransitiveActivity) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *IntransitiveActivity) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A Collection is a subtype of Object that represents ordered or unordered sets of Object or Link instances. Refer to the Activity Streams 2.0 Core specification for a complete description of the Collection type. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Collection struct {
	// The raw type from the vocab package
	raw *vocab.Collection
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Collection) Raw() (n *vocab.Collection) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Collection) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetTotalItems attempts to get this 'totalItems' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetTotalItems() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsTotalItems() {
		k = t.raw.GetTotalItems()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTotalItemsIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasTotalItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasTotalItems() (p Presence) {
	p = NoPresence
	if t.raw.IsTotalItems() {
		p = ConvenientPresence
	} else if t.raw.IsTotalItemsIRI() {
		p = RawPresence
	}
	return

}

// SetTotalItems sets the value for property 'totalItems'.
func (t *Collection) SetTotalItems(k int64) {
	t.raw.SetTotalItems(k)

}

// GetCurrent attempts to get this 'current' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetCurrent() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCurrentIRI() {
		k = t.raw.GetCurrentIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCurrentCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsCurrentLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasCurrent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasCurrent() (p Presence) {
	p = NoPresence
	if t.raw.IsCurrentIRI() {
		p = ConvenientPresence
	} else if t.raw.IsCurrentCollectionPage() {
		p = RawPresence
	} else if t.raw.IsCurrentLink() {
		p = RawPresence
	}
	return

}

// SetCurrent sets the value for property 'current'.
func (t *Collection) SetCurrent(k url.URL) {
	t.raw.SetCurrentIRI(k)

}

// GetFirst attempts to get this 'first' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetFirst() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsFirstIRI() {
		k = t.raw.GetFirstIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsFirstCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsFirstLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasFirst returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasFirst() (p Presence) {
	p = NoPresence
	if t.raw.IsFirstIRI() {
		p = ConvenientPresence
	} else if t.raw.IsFirstCollectionPage() {
		p = RawPresence
	} else if t.raw.IsFirstLink() {
		p = RawPresence
	}
	return

}

// SetFirst sets the value for property 'first'.
func (t *Collection) SetFirst(k url.URL) {
	t.raw.SetFirstIRI(k)

}

// GetLast attempts to get this 'last' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetLast() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsLastIRI() {
		k = t.raw.GetLastIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLastCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsLastLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasLast returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasLast() (p Presence) {
	p = NoPresence
	if t.raw.IsLastIRI() {
		p = ConvenientPresence
	} else if t.raw.IsLastCollectionPage() {
		p = RawPresence
	} else if t.raw.IsLastLink() {
		p = RawPresence
	}
	return

}

// SetLast sets the value for property 'last'.
func (t *Collection) SetLast(k url.URL) {
	t.raw.SetLastIRI(k)

}

// LenItems returns the number of values this property contains. Each index be used with HasItems to determine if ResolveItems is safe to call or if raw handling would be needed.%!(EXTRA string=items)
func (t *Collection) LenItems() (idx int) {
	return t.raw.ItemsLen()

}

// ResolveItems passes the actual concrete type to the resolver for handing property items. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddItems adds an 'Object' typed value.
func (t *Collection) AddItems(i vocab.ObjectType) {
	t.raw.AddItemsObject(i)

}

// SetItemsLink adds a 'Link' typed value.
func (t *Collection) SetItemsLink(i vocab.LinkType) {
	t.raw.AddItemsLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Collection) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Collection) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Collection) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Collection) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Collection) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Collection) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Collection) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Collection) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Collection) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Collection) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Collection) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Collection) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Collection) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Collection) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Collection) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Collection) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Collection) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Collection) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Collection) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Collection) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Collection) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Collection) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Collection) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Collection) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Collection) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Collection) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Collection) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Collection) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Collection) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Collection) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Collection) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Collection) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Collection) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Collection) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Collection) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Collection) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Collection) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Collection) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Collection) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Collection) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Collection) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Collection) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Collection) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Collection) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Collection) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Collection) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Collection) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Collection) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Collection) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Collection) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Collection) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Collection) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Collection) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Collection) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Collection) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Collection) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Collection) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Collection) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Collection) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Collection) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Collection) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Collection) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Collection) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Collection) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Collection) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Collection) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Collection) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Collection) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Collection) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Collection) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Collection) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Collection) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Collection) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Collection) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Collection) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Collection) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Collection) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Collection) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Collection) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Collection) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Collection) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Collection) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Collection) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Collection) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Collection) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Collection) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Collection) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Collection) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Collection) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Collection) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Collection) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Collection) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Collection) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Collection) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Collection) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Collection) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Collection) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Collection) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Collection) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Collection) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A subtype of Collection in which members of the logical collection are assumed to always be strictly ordered. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type OrderedCollection struct {
	// The raw type from the vocab package
	raw *vocab.OrderedCollection
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *OrderedCollection) Raw() (n *vocab.OrderedCollection) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *OrderedCollection) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenOrderedItems returns the number of values this property contains. Each index be used with HasOrderedItems to determine if ResolveOrderedItems is safe to call or if raw handling would be needed.%!(EXTRA string=orderedItems)
func (t *OrderedCollection) LenOrderedItems() (idx int) {
	return t.raw.OrderedItemsLen()

}

// ResolveOrderedItems passes the actual concrete type to the resolver for handing property orderedItems. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveOrderedItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOrderedItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetOrderedItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOrderedItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetOrderedItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOrderedItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrderedItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasOrderedItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOrderedItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOrderedItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOrderedItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrderedItems adds an 'Object' typed value.
func (t *OrderedCollection) AddOrderedItems(i vocab.ObjectType) {
	t.raw.AddOrderedItemsObject(i)

}

// SetOrderedItemsLink adds a 'Link' typed value.
func (t *OrderedCollection) SetOrderedItemsLink(i vocab.LinkType) {
	t.raw.AddOrderedItemsLink(i)

}

// GetTotalItems attempts to get this 'totalItems' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetTotalItems() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsTotalItems() {
		k = t.raw.GetTotalItems()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTotalItemsIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasTotalItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasTotalItems() (p Presence) {
	p = NoPresence
	if t.raw.IsTotalItems() {
		p = ConvenientPresence
	} else if t.raw.IsTotalItemsIRI() {
		p = RawPresence
	}
	return

}

// SetTotalItems sets the value for property 'totalItems'.
func (t *OrderedCollection) SetTotalItems(k int64) {
	t.raw.SetTotalItems(k)

}

// GetCurrent attempts to get this 'current' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetCurrent() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCurrentIRI() {
		k = t.raw.GetCurrentIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCurrentCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsCurrentLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasCurrent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasCurrent() (p Presence) {
	p = NoPresence
	if t.raw.IsCurrentIRI() {
		p = ConvenientPresence
	} else if t.raw.IsCurrentCollectionPage() {
		p = RawPresence
	} else if t.raw.IsCurrentLink() {
		p = RawPresence
	}
	return

}

// SetCurrent sets the value for property 'current'.
func (t *OrderedCollection) SetCurrent(k url.URL) {
	t.raw.SetCurrentIRI(k)

}

// GetFirst attempts to get this 'first' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetFirst() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsFirstIRI() {
		k = t.raw.GetFirstIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsFirstCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsFirstLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasFirst returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasFirst() (p Presence) {
	p = NoPresence
	if t.raw.IsFirstIRI() {
		p = ConvenientPresence
	} else if t.raw.IsFirstCollectionPage() {
		p = RawPresence
	} else if t.raw.IsFirstLink() {
		p = RawPresence
	}
	return

}

// SetFirst sets the value for property 'first'.
func (t *OrderedCollection) SetFirst(k url.URL) {
	t.raw.SetFirstIRI(k)

}

// GetLast attempts to get this 'last' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetLast() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsLastIRI() {
		k = t.raw.GetLastIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLastCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsLastLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasLast returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasLast() (p Presence) {
	p = NoPresence
	if t.raw.IsLastIRI() {
		p = ConvenientPresence
	} else if t.raw.IsLastCollectionPage() {
		p = RawPresence
	} else if t.raw.IsLastLink() {
		p = RawPresence
	}
	return

}

// SetLast sets the value for property 'last'.
func (t *OrderedCollection) SetLast(k url.URL) {
	t.raw.SetLastIRI(k)

}

// LenItems returns the number of values this property contains. Each index be used with HasItems to determine if ResolveItems is safe to call or if raw handling would be needed.%!(EXTRA string=items)
func (t *OrderedCollection) LenItems() (idx int) {
	return t.raw.ItemsLen()

}

// ResolveItems passes the actual concrete type to the resolver for handing property items. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddItems adds an 'Object' typed value.
func (t *OrderedCollection) AddItems(i vocab.ObjectType) {
	t.raw.AddItemsObject(i)

}

// SetItemsLink adds a 'Link' typed value.
func (t *OrderedCollection) SetItemsLink(i vocab.LinkType) {
	t.raw.AddItemsLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *OrderedCollection) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *OrderedCollection) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *OrderedCollection) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *OrderedCollection) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *OrderedCollection) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *OrderedCollection) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *OrderedCollection) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *OrderedCollection) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *OrderedCollection) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *OrderedCollection) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *OrderedCollection) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *OrderedCollection) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *OrderedCollection) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollection) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *OrderedCollection) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *OrderedCollection) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *OrderedCollection) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *OrderedCollection) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *OrderedCollection) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *OrderedCollection) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *OrderedCollection) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *OrderedCollection) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollection) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *OrderedCollection) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *OrderedCollection) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *OrderedCollection) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *OrderedCollection) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *OrderedCollection) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *OrderedCollection) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *OrderedCollection) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *OrderedCollection) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *OrderedCollection) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *OrderedCollection) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *OrderedCollection) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *OrderedCollection) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *OrderedCollection) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *OrderedCollection) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *OrderedCollection) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *OrderedCollection) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *OrderedCollection) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *OrderedCollection) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *OrderedCollection) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *OrderedCollection) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *OrderedCollection) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *OrderedCollection) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *OrderedCollection) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *OrderedCollection) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *OrderedCollection) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *OrderedCollection) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *OrderedCollection) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *OrderedCollection) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollection) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *OrderedCollection) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *OrderedCollection) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *OrderedCollection) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *OrderedCollection) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *OrderedCollection) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *OrderedCollection) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *OrderedCollection) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *OrderedCollection) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *OrderedCollection) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *OrderedCollection) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *OrderedCollection) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *OrderedCollection) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *OrderedCollection) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *OrderedCollection) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *OrderedCollection) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *OrderedCollection) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *OrderedCollection) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *OrderedCollection) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *OrderedCollection) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *OrderedCollection) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *OrderedCollection) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *OrderedCollection) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *OrderedCollection) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *OrderedCollection) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *OrderedCollection) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *OrderedCollection) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *OrderedCollection) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *OrderedCollection) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *OrderedCollection) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *OrderedCollection) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *OrderedCollection) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *OrderedCollection) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *OrderedCollection) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *OrderedCollection) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *OrderedCollection) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *OrderedCollection) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollection) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *OrderedCollection) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *OrderedCollection) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *OrderedCollection) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *OrderedCollection) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *OrderedCollection) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *OrderedCollection) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *OrderedCollection) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *OrderedCollection) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollection) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollection) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *OrderedCollection) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Used to represent distinct subsets of items from a Collection. Refer to the Activity Streams 2.0 Core for a complete description of the CollectionPage object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type CollectionPage struct {
	// The raw type from the vocab package
	raw *vocab.CollectionPage
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *CollectionPage) Raw() (n *vocab.CollectionPage) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *CollectionPage) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// ResolvePartOf passes the actual concrete type to the resolver for handing property partOf. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolvePartOf(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPartOfLink() {
		handled, err = r.dispatch(t.raw.GetPartOfLink())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPartOfCollection() {
		s = RawResolutionNeeded
	} else if t.raw.IsPartOfIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasPartOf returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasPartOf() (p Presence) {
	p = NoPresence
	if t.raw.IsPartOfLink() {
		p = ConvenientPresence
	} else if t.raw.IsPartOfCollection() {
		p = RawPresence
	} else if t.raw.IsPartOfIRI() {
		p = RawPresence
	}
	return

}

// SetPartOf sets this value to be a 'Link' type.
func (t *CollectionPage) SetPartOf(i vocab.LinkType) {
	t.raw.SetPartOfLink(i)

}

// GetNext attempts to get this 'next' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetNext() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsNextIRI() {
		k = t.raw.GetNextIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNextCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsNextLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasNext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasNext() (p Presence) {
	p = NoPresence
	if t.raw.IsNextIRI() {
		p = ConvenientPresence
	} else if t.raw.IsNextCollectionPage() {
		p = RawPresence
	} else if t.raw.IsNextLink() {
		p = RawPresence
	}
	return

}

// SetNext sets the value for property 'next'.
func (t *CollectionPage) SetNext(k url.URL) {
	t.raw.SetNextIRI(k)

}

// GetPrev attempts to get this 'prev' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetPrev() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsPrevIRI() {
		k = t.raw.GetPrevIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPrevCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsPrevLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasPrev returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasPrev() (p Presence) {
	p = NoPresence
	if t.raw.IsPrevIRI() {
		p = ConvenientPresence
	} else if t.raw.IsPrevCollectionPage() {
		p = RawPresence
	} else if t.raw.IsPrevLink() {
		p = RawPresence
	}
	return

}

// SetPrev sets the value for property 'prev'.
func (t *CollectionPage) SetPrev(k url.URL) {
	t.raw.SetPrevIRI(k)

}

// GetTotalItems attempts to get this 'totalItems' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetTotalItems() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsTotalItems() {
		k = t.raw.GetTotalItems()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTotalItemsIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasTotalItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasTotalItems() (p Presence) {
	p = NoPresence
	if t.raw.IsTotalItems() {
		p = ConvenientPresence
	} else if t.raw.IsTotalItemsIRI() {
		p = RawPresence
	}
	return

}

// SetTotalItems sets the value for property 'totalItems'.
func (t *CollectionPage) SetTotalItems(k int64) {
	t.raw.SetTotalItems(k)

}

// GetCurrent attempts to get this 'current' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetCurrent() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCurrentIRI() {
		k = t.raw.GetCurrentIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCurrentCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsCurrentLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasCurrent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasCurrent() (p Presence) {
	p = NoPresence
	if t.raw.IsCurrentIRI() {
		p = ConvenientPresence
	} else if t.raw.IsCurrentCollectionPage() {
		p = RawPresence
	} else if t.raw.IsCurrentLink() {
		p = RawPresence
	}
	return

}

// SetCurrent sets the value for property 'current'.
func (t *CollectionPage) SetCurrent(k url.URL) {
	t.raw.SetCurrentIRI(k)

}

// GetFirst attempts to get this 'first' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetFirst() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsFirstIRI() {
		k = t.raw.GetFirstIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsFirstCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsFirstLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasFirst returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasFirst() (p Presence) {
	p = NoPresence
	if t.raw.IsFirstIRI() {
		p = ConvenientPresence
	} else if t.raw.IsFirstCollectionPage() {
		p = RawPresence
	} else if t.raw.IsFirstLink() {
		p = RawPresence
	}
	return

}

// SetFirst sets the value for property 'first'.
func (t *CollectionPage) SetFirst(k url.URL) {
	t.raw.SetFirstIRI(k)

}

// GetLast attempts to get this 'last' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetLast() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsLastIRI() {
		k = t.raw.GetLastIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLastCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsLastLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasLast returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasLast() (p Presence) {
	p = NoPresence
	if t.raw.IsLastIRI() {
		p = ConvenientPresence
	} else if t.raw.IsLastCollectionPage() {
		p = RawPresence
	} else if t.raw.IsLastLink() {
		p = RawPresence
	}
	return

}

// SetLast sets the value for property 'last'.
func (t *CollectionPage) SetLast(k url.URL) {
	t.raw.SetLastIRI(k)

}

// LenItems returns the number of values this property contains. Each index be used with HasItems to determine if ResolveItems is safe to call or if raw handling would be needed.%!(EXTRA string=items)
func (t *CollectionPage) LenItems() (idx int) {
	return t.raw.ItemsLen()

}

// ResolveItems passes the actual concrete type to the resolver for handing property items. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddItems adds an 'Object' typed value.
func (t *CollectionPage) AddItems(i vocab.ObjectType) {
	t.raw.AddItemsObject(i)

}

// SetItemsLink adds a 'Link' typed value.
func (t *CollectionPage) SetItemsLink(i vocab.LinkType) {
	t.raw.AddItemsLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *CollectionPage) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *CollectionPage) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *CollectionPage) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *CollectionPage) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *CollectionPage) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *CollectionPage) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *CollectionPage) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *CollectionPage) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *CollectionPage) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *CollectionPage) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *CollectionPage) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *CollectionPage) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *CollectionPage) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *CollectionPage) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *CollectionPage) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *CollectionPage) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *CollectionPage) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *CollectionPage) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *CollectionPage) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *CollectionPage) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *CollectionPage) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *CollectionPage) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *CollectionPage) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *CollectionPage) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *CollectionPage) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *CollectionPage) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *CollectionPage) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *CollectionPage) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *CollectionPage) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *CollectionPage) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *CollectionPage) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *CollectionPage) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *CollectionPage) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *CollectionPage) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *CollectionPage) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *CollectionPage) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *CollectionPage) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *CollectionPage) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *CollectionPage) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *CollectionPage) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *CollectionPage) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *CollectionPage) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *CollectionPage) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *CollectionPage) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *CollectionPage) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *CollectionPage) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *CollectionPage) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *CollectionPage) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *CollectionPage) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *CollectionPage) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *CollectionPage) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *CollectionPage) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *CollectionPage) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *CollectionPage) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *CollectionPage) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *CollectionPage) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *CollectionPage) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *CollectionPage) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *CollectionPage) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *CollectionPage) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *CollectionPage) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *CollectionPage) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *CollectionPage) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *CollectionPage) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *CollectionPage) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *CollectionPage) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *CollectionPage) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *CollectionPage) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *CollectionPage) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *CollectionPage) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *CollectionPage) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *CollectionPage) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *CollectionPage) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *CollectionPage) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *CollectionPage) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *CollectionPage) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *CollectionPage) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *CollectionPage) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *CollectionPage) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *CollectionPage) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *CollectionPage) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *CollectionPage) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *CollectionPage) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *CollectionPage) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *CollectionPage) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *CollectionPage) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *CollectionPage) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *CollectionPage) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *CollectionPage) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *CollectionPage) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *CollectionPage) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *CollectionPage) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *CollectionPage) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *CollectionPage) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *CollectionPage) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *CollectionPage) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *CollectionPage) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *CollectionPage) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *CollectionPage) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *CollectionPage) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Used to represent ordered subsets of items from an OrderedCollection. Refer to the Activity Streams 2.0 Core for a complete description of the OrderedCollectionPage object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type OrderedCollectionPage struct {
	// The raw type from the vocab package
	raw *vocab.OrderedCollectionPage
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *OrderedCollectionPage) Raw() (n *vocab.OrderedCollectionPage) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *OrderedCollectionPage) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetStartIndex attempts to get this 'startIndex' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetStartIndex() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsStartIndex() {
		k = t.raw.GetStartIndex()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartIndexIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartIndex returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasStartIndex() (p Presence) {
	p = NoPresence
	if t.raw.IsStartIndex() {
		p = ConvenientPresence
	} else if t.raw.IsStartIndexIRI() {
		p = RawPresence
	}
	return

}

// SetStartIndex sets the value for property 'startIndex'.
func (t *OrderedCollectionPage) SetStartIndex(k int64) {
	t.raw.SetStartIndex(k)

}

// LenOrderedItems returns the number of values this property contains. Each index be used with HasOrderedItems to determine if ResolveOrderedItems is safe to call or if raw handling would be needed.%!(EXTRA string=orderedItems)
func (t *OrderedCollectionPage) LenOrderedItems() (idx int) {
	return t.raw.OrderedItemsLen()

}

// ResolveOrderedItems passes the actual concrete type to the resolver for handing property orderedItems. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveOrderedItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOrderedItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetOrderedItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOrderedItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetOrderedItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOrderedItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrderedItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasOrderedItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOrderedItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOrderedItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOrderedItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrderedItems adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddOrderedItems(i vocab.ObjectType) {
	t.raw.AddOrderedItemsObject(i)

}

// SetOrderedItemsLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetOrderedItemsLink(i vocab.LinkType) {
	t.raw.AddOrderedItemsLink(i)

}

// GetTotalItems attempts to get this 'totalItems' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetTotalItems() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsTotalItems() {
		k = t.raw.GetTotalItems()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTotalItemsIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasTotalItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasTotalItems() (p Presence) {
	p = NoPresence
	if t.raw.IsTotalItems() {
		p = ConvenientPresence
	} else if t.raw.IsTotalItemsIRI() {
		p = RawPresence
	}
	return

}

// SetTotalItems sets the value for property 'totalItems'.
func (t *OrderedCollectionPage) SetTotalItems(k int64) {
	t.raw.SetTotalItems(k)

}

// GetCurrent attempts to get this 'current' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetCurrent() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCurrentIRI() {
		k = t.raw.GetCurrentIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCurrentCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsCurrentLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasCurrent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasCurrent() (p Presence) {
	p = NoPresence
	if t.raw.IsCurrentIRI() {
		p = ConvenientPresence
	} else if t.raw.IsCurrentCollectionPage() {
		p = RawPresence
	} else if t.raw.IsCurrentLink() {
		p = RawPresence
	}
	return

}

// SetCurrent sets the value for property 'current'.
func (t *OrderedCollectionPage) SetCurrent(k url.URL) {
	t.raw.SetCurrentIRI(k)

}

// GetFirst attempts to get this 'first' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetFirst() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsFirstIRI() {
		k = t.raw.GetFirstIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsFirstCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsFirstLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasFirst returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasFirst() (p Presence) {
	p = NoPresence
	if t.raw.IsFirstIRI() {
		p = ConvenientPresence
	} else if t.raw.IsFirstCollectionPage() {
		p = RawPresence
	} else if t.raw.IsFirstLink() {
		p = RawPresence
	}
	return

}

// SetFirst sets the value for property 'first'.
func (t *OrderedCollectionPage) SetFirst(k url.URL) {
	t.raw.SetFirstIRI(k)

}

// GetLast attempts to get this 'last' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetLast() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsLastIRI() {
		k = t.raw.GetLastIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLastCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsLastLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasLast returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasLast() (p Presence) {
	p = NoPresence
	if t.raw.IsLastIRI() {
		p = ConvenientPresence
	} else if t.raw.IsLastCollectionPage() {
		p = RawPresence
	} else if t.raw.IsLastLink() {
		p = RawPresence
	}
	return

}

// SetLast sets the value for property 'last'.
func (t *OrderedCollectionPage) SetLast(k url.URL) {
	t.raw.SetLastIRI(k)

}

// LenItems returns the number of values this property contains. Each index be used with HasItems to determine if ResolveItems is safe to call or if raw handling would be needed.%!(EXTRA string=items)
func (t *OrderedCollectionPage) LenItems() (idx int) {
	return t.raw.ItemsLen()

}

// ResolveItems passes the actual concrete type to the resolver for handing property items. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveItems(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsItemsObject(idx) {
		handled, err = r.dispatch(t.raw.GetItemsObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsLink(idx) {
		handled, err = r.dispatch(t.raw.GetItemsLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsItemsIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasItems returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasItems(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsItemsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsItemsIRI(idx) {
		p = RawPresence
	}
	return

}

// AddItems adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddItems(i vocab.ObjectType) {
	t.raw.AddItemsObject(i)

}

// SetItemsLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetItemsLink(i vocab.LinkType) {
	t.raw.AddItemsLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *OrderedCollectionPage) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *OrderedCollectionPage) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *OrderedCollectionPage) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *OrderedCollectionPage) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *OrderedCollectionPage) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *OrderedCollectionPage) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *OrderedCollectionPage) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *OrderedCollectionPage) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *OrderedCollectionPage) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *OrderedCollectionPage) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *OrderedCollectionPage) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollectionPage) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *OrderedCollectionPage) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *OrderedCollectionPage) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *OrderedCollectionPage) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *OrderedCollectionPage) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *OrderedCollectionPage) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *OrderedCollectionPage) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollectionPage) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *OrderedCollectionPage) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *OrderedCollectionPage) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *OrderedCollectionPage) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *OrderedCollectionPage) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *OrderedCollectionPage) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *OrderedCollectionPage) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *OrderedCollectionPage) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *OrderedCollectionPage) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *OrderedCollectionPage) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *OrderedCollectionPage) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *OrderedCollectionPage) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *OrderedCollectionPage) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *OrderedCollectionPage) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *OrderedCollectionPage) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *OrderedCollectionPage) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *OrderedCollectionPage) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *OrderedCollectionPage) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *OrderedCollectionPage) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *OrderedCollectionPage) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *OrderedCollectionPage) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *OrderedCollectionPage) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *OrderedCollectionPage) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollectionPage) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *OrderedCollectionPage) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *OrderedCollectionPage) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *OrderedCollectionPage) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *OrderedCollectionPage) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *OrderedCollectionPage) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *OrderedCollectionPage) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *OrderedCollectionPage) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *OrderedCollectionPage) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *OrderedCollectionPage) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *OrderedCollectionPage) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *OrderedCollectionPage) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *OrderedCollectionPage) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *OrderedCollectionPage) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *OrderedCollectionPage) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *OrderedCollectionPage) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *OrderedCollectionPage) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *OrderedCollectionPage) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *OrderedCollectionPage) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *OrderedCollectionPage) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *OrderedCollectionPage) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *OrderedCollectionPage) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *OrderedCollectionPage) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *OrderedCollectionPage) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *OrderedCollectionPage) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *OrderedCollectionPage) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *OrderedCollectionPage) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *OrderedCollectionPage) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *OrderedCollectionPage) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *OrderedCollectionPage) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *OrderedCollectionPage) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *OrderedCollectionPage) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *OrderedCollectionPage) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *OrderedCollectionPage) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *OrderedCollectionPage) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *OrderedCollectionPage) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *OrderedCollectionPage) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *OrderedCollectionPage) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *OrderedCollectionPage) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *OrderedCollectionPage) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *OrderedCollectionPage) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *OrderedCollectionPage) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *OrderedCollectionPage) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *OrderedCollectionPage) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *OrderedCollectionPage) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *OrderedCollectionPage) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *OrderedCollectionPage) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// ResolvePartOf passes the actual concrete type to the resolver for handing property partOf. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) ResolvePartOf(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPartOfLink() {
		handled, err = r.dispatch(t.raw.GetPartOfLink())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPartOfCollection() {
		s = RawResolutionNeeded
	} else if t.raw.IsPartOfIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasPartOf returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasPartOf() (p Presence) {
	p = NoPresence
	if t.raw.IsPartOfLink() {
		p = ConvenientPresence
	} else if t.raw.IsPartOfCollection() {
		p = RawPresence
	} else if t.raw.IsPartOfIRI() {
		p = RawPresence
	}
	return

}

// SetPartOf sets this value to be a 'Link' type.
func (t *OrderedCollectionPage) SetPartOf(i vocab.LinkType) {
	t.raw.SetPartOfLink(i)

}

// GetNext attempts to get this 'next' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetNext() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsNextIRI() {
		k = t.raw.GetNextIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNextCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsNextLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasNext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasNext() (p Presence) {
	p = NoPresence
	if t.raw.IsNextIRI() {
		p = ConvenientPresence
	} else if t.raw.IsNextCollectionPage() {
		p = RawPresence
	} else if t.raw.IsNextLink() {
		p = RawPresence
	}
	return

}

// SetNext sets the value for property 'next'.
func (t *OrderedCollectionPage) SetNext(k url.URL) {
	t.raw.SetNextIRI(k)

}

// GetPrev attempts to get this 'prev' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *OrderedCollectionPage) GetPrev() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsPrevIRI() {
		k = t.raw.GetPrevIRI()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPrevCollectionPage() {
		r = RawResolutionNeeded
	} else if t.raw.IsPrevLink() {
		r = RawResolutionNeeded
	}
	return

}

// HasPrev returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *OrderedCollectionPage) HasPrev() (p Presence) {
	p = NoPresence
	if t.raw.IsPrevIRI() {
		p = ConvenientPresence
	} else if t.raw.IsPrevCollectionPage() {
		p = RawPresence
	} else if t.raw.IsPrevLink() {
		p = RawPresence
	}
	return

}

// SetPrev sets the value for property 'prev'.
func (t *OrderedCollectionPage) SetPrev(k url.URL) {
	t.raw.SetPrevIRI(k)

}

// Indicates that the actor accepts the object. The target property can be used in certain circumstances to indicate the context into which the object has been accepted. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Accept struct {
	// The raw type from the vocab package
	raw *vocab.Accept
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Accept) Raw() (n *vocab.Accept) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Accept) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Accept) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Accept) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Accept) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Accept) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Accept) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Accept) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Accept) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Accept) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Accept) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Accept) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Accept) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Accept) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Accept) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Accept) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Accept) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Accept) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Accept) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Accept) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Accept) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Accept) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Accept) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Accept) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Accept) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Accept) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Accept) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Accept) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Accept) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Accept) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Accept) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Accept) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Accept) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Accept) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Accept) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Accept) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Accept) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Accept) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Accept) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Accept) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Accept) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Accept) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Accept) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Accept) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Accept) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Accept) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Accept) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Accept) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Accept) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Accept) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Accept) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Accept) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Accept) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Accept) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Accept) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Accept) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Accept) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Accept) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Accept) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Accept) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Accept) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Accept) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Accept) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Accept) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Accept) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Accept) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Accept) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Accept) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Accept) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Accept) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Accept) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Accept) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Accept) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Accept) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Accept) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Accept) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Accept) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Accept) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Accept) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Accept) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Accept) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Accept) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Accept) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Accept) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Accept) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Accept) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Accept) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Accept) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Accept) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Accept) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Accept) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Accept) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Accept) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Accept) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Accept) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Accept) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Accept) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Accept) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Accept) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Accept) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Accept) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Accept) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Accept) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Accept) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Accept) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Accept) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Accept) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Accept) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Accept) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Accept) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Accept) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Accept) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Accept) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Accept) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Accept) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Accept) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Accept) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Accept) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Accept) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Accept) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A specialization of Accept indicating that the acceptance is tentative. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type TentativeAccept struct {
	// The raw type from the vocab package
	raw *vocab.TentativeAccept
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *TentativeAccept) Raw() (n *vocab.TentativeAccept) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *TentativeAccept) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *TentativeAccept) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *TentativeAccept) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *TentativeAccept) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *TentativeAccept) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *TentativeAccept) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *TentativeAccept) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *TentativeAccept) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *TentativeAccept) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *TentativeAccept) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *TentativeAccept) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *TentativeAccept) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *TentativeAccept) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *TentativeAccept) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *TentativeAccept) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *TentativeAccept) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *TentativeAccept) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *TentativeAccept) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *TentativeAccept) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *TentativeAccept) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *TentativeAccept) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *TentativeAccept) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *TentativeAccept) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *TentativeAccept) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *TentativeAccept) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *TentativeAccept) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *TentativeAccept) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *TentativeAccept) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *TentativeAccept) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *TentativeAccept) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *TentativeAccept) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *TentativeAccept) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeAccept) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *TentativeAccept) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *TentativeAccept) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *TentativeAccept) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *TentativeAccept) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *TentativeAccept) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *TentativeAccept) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *TentativeAccept) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *TentativeAccept) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeAccept) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *TentativeAccept) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *TentativeAccept) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *TentativeAccept) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *TentativeAccept) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *TentativeAccept) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *TentativeAccept) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *TentativeAccept) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *TentativeAccept) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *TentativeAccept) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *TentativeAccept) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *TentativeAccept) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *TentativeAccept) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *TentativeAccept) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *TentativeAccept) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *TentativeAccept) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *TentativeAccept) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *TentativeAccept) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *TentativeAccept) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *TentativeAccept) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *TentativeAccept) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *TentativeAccept) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *TentativeAccept) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *TentativeAccept) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *TentativeAccept) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *TentativeAccept) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *TentativeAccept) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *TentativeAccept) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *TentativeAccept) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeAccept) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *TentativeAccept) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *TentativeAccept) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *TentativeAccept) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *TentativeAccept) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *TentativeAccept) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *TentativeAccept) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *TentativeAccept) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *TentativeAccept) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *TentativeAccept) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *TentativeAccept) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *TentativeAccept) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *TentativeAccept) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *TentativeAccept) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *TentativeAccept) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *TentativeAccept) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *TentativeAccept) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *TentativeAccept) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *TentativeAccept) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *TentativeAccept) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *TentativeAccept) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *TentativeAccept) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *TentativeAccept) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *TentativeAccept) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *TentativeAccept) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *TentativeAccept) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *TentativeAccept) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *TentativeAccept) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *TentativeAccept) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *TentativeAccept) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *TentativeAccept) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *TentativeAccept) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *TentativeAccept) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *TentativeAccept) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *TentativeAccept) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *TentativeAccept) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *TentativeAccept) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeAccept) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *TentativeAccept) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *TentativeAccept) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *TentativeAccept) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *TentativeAccept) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *TentativeAccept) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *TentativeAccept) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *TentativeAccept) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *TentativeAccept) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeAccept) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeAccept) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *TentativeAccept) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has added the object to the target. If the target property is not explicitly specified, the target would need to be determined implicitly by context. The origin can be used to identify the context from which the object originated. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Add struct {
	// The raw type from the vocab package
	raw *vocab.Add
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Add) Raw() (n *vocab.Add) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Add) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Add) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Add) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Add) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Add) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Add) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Add) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Add) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Add) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Add) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Add) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Add) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Add) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Add) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Add) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Add) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Add) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Add) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Add) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Add) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Add) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Add) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Add) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Add) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Add) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Add) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Add) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Add) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Add) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Add) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Add) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Add) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Add) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Add) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Add) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Add) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Add) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Add) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Add) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Add) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Add) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Add) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Add) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Add) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Add) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Add) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Add) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Add) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Add) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Add) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Add) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Add) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Add) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Add) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Add) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Add) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Add) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Add) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Add) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Add) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Add) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Add) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Add) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Add) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Add) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Add) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Add) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Add) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Add) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Add) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Add) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Add) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Add) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Add) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Add) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Add) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Add) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Add) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Add) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Add) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Add) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Add) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Add) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Add) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Add) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Add) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Add) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Add) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Add) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Add) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Add) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Add) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Add) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Add) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Add) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Add) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Add) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Add) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Add) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Add) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Add) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Add) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Add) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Add) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Add) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Add) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Add) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Add) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Add) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Add) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Add) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Add) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Add) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Add) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Add) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Add) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Add) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Add) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Add) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// An IntransitiveActivity that indicates that the actor has arrived at the location. The origin can be used to identify the context from which the actor originated. The target typically has no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Arrive struct {
	// The raw type from the vocab package
	raw *vocab.Arrive
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Arrive) Raw() (n *vocab.Arrive) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Arrive) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Arrive) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Arrive) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Arrive) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Arrive) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Arrive) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Arrive) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Arrive) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Arrive) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Arrive) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Arrive) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Arrive) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Arrive) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Arrive) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Arrive) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Arrive) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Arrive) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Arrive) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Arrive) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Arrive) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Arrive) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Arrive) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Arrive) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Arrive) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Arrive) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Arrive) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Arrive) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Arrive) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Arrive) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Arrive) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Arrive) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Arrive) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Arrive) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Arrive) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Arrive) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Arrive) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Arrive) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Arrive) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Arrive) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Arrive) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Arrive) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Arrive) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Arrive) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Arrive) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Arrive) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Arrive) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Arrive) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Arrive) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Arrive) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Arrive) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Arrive) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Arrive) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Arrive) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Arrive) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Arrive) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Arrive) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Arrive) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Arrive) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Arrive) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Arrive) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Arrive) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Arrive) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Arrive) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Arrive) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Arrive) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Arrive) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Arrive) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Arrive) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Arrive) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Arrive) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Arrive) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Arrive) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Arrive) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Arrive) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Arrive) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Arrive) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Arrive) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Arrive) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Arrive) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Arrive) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Arrive) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Arrive) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Arrive) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Arrive) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Arrive) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Arrive) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Arrive) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Arrive) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Arrive) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Arrive) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Arrive) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Arrive) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Arrive) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Arrive) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Arrive) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Arrive) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Arrive) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Arrive) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Arrive) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Arrive) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Arrive) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Arrive) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Arrive) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Arrive) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Arrive) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Arrive) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Arrive) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Arrive) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Arrive) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Arrive) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Arrive) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Arrive) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Arrive) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Arrive) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Arrive) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Arrive) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has created the object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Create struct {
	// The raw type from the vocab package
	raw *vocab.Create
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Create) Raw() (n *vocab.Create) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Create) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Create) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Create) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Create) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Create) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Create) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Create) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Create) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Create) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Create) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Create) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Create) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Create) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Create) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Create) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Create) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Create) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Create) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Create) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Create) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Create) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Create) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Create) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Create) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Create) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Create) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Create) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Create) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Create) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Create) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Create) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Create) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Create) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Create) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Create) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Create) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Create) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Create) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Create) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Create) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Create) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Create) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Create) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Create) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Create) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Create) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Create) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Create) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Create) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Create) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Create) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Create) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Create) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Create) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Create) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Create) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Create) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Create) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Create) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Create) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Create) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Create) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Create) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Create) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Create) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Create) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Create) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Create) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Create) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Create) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Create) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Create) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Create) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Create) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Create) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Create) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Create) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Create) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Create) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Create) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Create) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Create) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Create) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Create) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Create) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Create) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Create) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Create) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Create) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Create) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Create) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Create) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Create) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Create) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Create) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Create) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Create) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Create) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Create) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Create) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Create) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Create) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Create) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Create) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Create) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Create) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Create) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Create) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Create) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Create) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Create) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Create) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Create) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Create) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Create) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Create) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Create) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Create) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Create) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has deleted the object. If specified, the origin indicates the context from which the object was deleted. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Delete struct {
	// The raw type from the vocab package
	raw *vocab.Delete
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Delete) Raw() (n *vocab.Delete) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Delete) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Delete) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Delete) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Delete) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Delete) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Delete) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Delete) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Delete) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Delete) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Delete) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Delete) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Delete) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Delete) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Delete) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Delete) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Delete) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Delete) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Delete) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Delete) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Delete) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Delete) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Delete) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Delete) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Delete) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Delete) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Delete) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Delete) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Delete) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Delete) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Delete) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Delete) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Delete) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Delete) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Delete) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Delete) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Delete) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Delete) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Delete) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Delete) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Delete) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Delete) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Delete) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Delete) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Delete) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Delete) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Delete) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Delete) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Delete) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Delete) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Delete) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Delete) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Delete) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Delete) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Delete) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Delete) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Delete) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Delete) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Delete) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Delete) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Delete) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Delete) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Delete) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Delete) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Delete) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Delete) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Delete) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Delete) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Delete) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Delete) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Delete) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Delete) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Delete) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Delete) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Delete) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Delete) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Delete) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Delete) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Delete) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Delete) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Delete) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Delete) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Delete) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Delete) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Delete) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Delete) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Delete) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Delete) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Delete) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Delete) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Delete) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Delete) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Delete) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Delete) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Delete) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Delete) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Delete) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Delete) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Delete) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Delete) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Delete) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Delete) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Delete) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Delete) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Delete) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Delete) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Delete) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Delete) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Delete) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Delete) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Delete) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Delete) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Delete) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Delete) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Delete) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Delete) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Delete) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Delete) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Delete) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Delete) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is "following" the object. Following is defined in the sense typically used within Social systems in which the actor is interested in any activity performed by or on the object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Follow struct {
	// The raw type from the vocab package
	raw *vocab.Follow
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Follow) Raw() (n *vocab.Follow) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Follow) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Follow) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Follow) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Follow) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Follow) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Follow) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Follow) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Follow) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Follow) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Follow) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Follow) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Follow) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Follow) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Follow) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Follow) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Follow) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Follow) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Follow) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Follow) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Follow) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Follow) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Follow) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Follow) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Follow) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Follow) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Follow) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Follow) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Follow) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Follow) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Follow) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Follow) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Follow) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Follow) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Follow) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Follow) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Follow) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Follow) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Follow) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Follow) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Follow) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Follow) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Follow) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Follow) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Follow) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Follow) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Follow) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Follow) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Follow) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Follow) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Follow) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Follow) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Follow) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Follow) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Follow) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Follow) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Follow) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Follow) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Follow) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Follow) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Follow) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Follow) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Follow) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Follow) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Follow) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Follow) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Follow) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Follow) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Follow) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Follow) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Follow) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Follow) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Follow) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Follow) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Follow) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Follow) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Follow) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Follow) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Follow) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Follow) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Follow) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Follow) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Follow) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Follow) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Follow) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Follow) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Follow) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Follow) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Follow) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Follow) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Follow) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Follow) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Follow) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Follow) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Follow) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Follow) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Follow) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Follow) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Follow) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Follow) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Follow) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Follow) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Follow) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Follow) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Follow) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Follow) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Follow) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Follow) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Follow) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Follow) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Follow) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Follow) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Follow) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Follow) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Follow) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Follow) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Follow) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Follow) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Follow) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Follow) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is ignoring the object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Ignore struct {
	// The raw type from the vocab package
	raw *vocab.Ignore
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Ignore) Raw() (n *vocab.Ignore) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Ignore) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Ignore) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Ignore) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Ignore) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Ignore) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Ignore) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Ignore) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Ignore) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Ignore) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Ignore) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Ignore) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Ignore) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Ignore) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Ignore) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Ignore) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Ignore) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Ignore) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Ignore) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Ignore) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Ignore) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Ignore) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Ignore) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Ignore) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Ignore) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Ignore) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Ignore) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Ignore) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Ignore) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Ignore) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Ignore) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Ignore) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Ignore) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Ignore) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Ignore) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Ignore) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Ignore) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Ignore) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Ignore) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Ignore) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Ignore) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Ignore) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Ignore) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Ignore) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Ignore) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Ignore) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Ignore) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Ignore) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Ignore) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Ignore) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Ignore) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Ignore) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Ignore) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Ignore) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Ignore) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Ignore) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Ignore) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Ignore) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Ignore) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Ignore) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Ignore) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Ignore) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Ignore) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Ignore) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Ignore) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Ignore) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Ignore) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Ignore) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Ignore) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Ignore) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Ignore) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Ignore) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Ignore) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Ignore) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Ignore) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Ignore) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Ignore) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Ignore) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Ignore) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Ignore) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Ignore) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Ignore) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Ignore) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Ignore) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Ignore) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Ignore) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Ignore) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Ignore) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Ignore) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Ignore) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Ignore) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Ignore) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Ignore) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Ignore) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Ignore) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Ignore) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Ignore) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Ignore) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Ignore) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Ignore) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Ignore) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Ignore) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Ignore) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Ignore) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Ignore) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Ignore) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Ignore) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Ignore) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Ignore) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Ignore) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Ignore) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Ignore) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Ignore) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Ignore) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Ignore) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Ignore) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Ignore) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Ignore) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Ignore) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Ignore) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has joined the object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Join struct {
	// The raw type from the vocab package
	raw *vocab.Join
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Join) Raw() (n *vocab.Join) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Join) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Join) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Join) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Join) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Join) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Join) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Join) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Join) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Join) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Join) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Join) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Join) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Join) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Join) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Join) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Join) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Join) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Join) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Join) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Join) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Join) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Join) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Join) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Join) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Join) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Join) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Join) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Join) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Join) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Join) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Join) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Join) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Join) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Join) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Join) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Join) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Join) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Join) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Join) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Join) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Join) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Join) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Join) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Join) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Join) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Join) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Join) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Join) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Join) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Join) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Join) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Join) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Join) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Join) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Join) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Join) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Join) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Join) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Join) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Join) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Join) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Join) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Join) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Join) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Join) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Join) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Join) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Join) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Join) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Join) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Join) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Join) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Join) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Join) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Join) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Join) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Join) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Join) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Join) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Join) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Join) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Join) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Join) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Join) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Join) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Join) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Join) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Join) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Join) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Join) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Join) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Join) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Join) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Join) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Join) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Join) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Join) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Join) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Join) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Join) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Join) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Join) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Join) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Join) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Join) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Join) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Join) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Join) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Join) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Join) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Join) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Join) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Join) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Join) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Join) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Join) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Join) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Join) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Join) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has left the object. The target and origin typically have no meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Leave struct {
	// The raw type from the vocab package
	raw *vocab.Leave
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Leave) Raw() (n *vocab.Leave) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Leave) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Leave) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Leave) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Leave) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Leave) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Leave) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Leave) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Leave) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Leave) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Leave) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Leave) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Leave) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Leave) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Leave) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Leave) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Leave) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Leave) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Leave) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Leave) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Leave) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Leave) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Leave) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Leave) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Leave) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Leave) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Leave) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Leave) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Leave) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Leave) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Leave) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Leave) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Leave) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Leave) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Leave) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Leave) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Leave) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Leave) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Leave) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Leave) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Leave) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Leave) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Leave) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Leave) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Leave) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Leave) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Leave) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Leave) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Leave) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Leave) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Leave) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Leave) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Leave) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Leave) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Leave) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Leave) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Leave) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Leave) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Leave) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Leave) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Leave) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Leave) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Leave) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Leave) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Leave) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Leave) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Leave) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Leave) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Leave) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Leave) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Leave) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Leave) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Leave) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Leave) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Leave) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Leave) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Leave) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Leave) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Leave) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Leave) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Leave) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Leave) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Leave) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Leave) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Leave) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Leave) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Leave) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Leave) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Leave) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Leave) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Leave) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Leave) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Leave) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Leave) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Leave) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Leave) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Leave) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Leave) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Leave) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Leave) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Leave) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Leave) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Leave) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Leave) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Leave) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Leave) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Leave) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Leave) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Leave) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Leave) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Leave) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Leave) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Leave) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Leave) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Leave) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Leave) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Leave) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Leave) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Leave) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Leave) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor likes, recommends or endorses the object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Like struct {
	// The raw type from the vocab package
	raw *vocab.Like
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Like) Raw() (n *vocab.Like) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Like) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Like) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Like) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Like) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Like) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Like) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Like) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Like) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Like) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Like) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Like) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Like) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Like) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Like) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Like) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Like) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Like) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Like) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Like) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Like) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Like) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Like) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Like) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Like) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Like) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Like) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Like) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Like) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Like) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Like) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Like) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Like) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Like) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Like) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Like) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Like) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Like) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Like) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Like) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Like) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Like) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Like) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Like) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Like) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Like) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Like) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Like) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Like) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Like) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Like) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Like) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Like) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Like) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Like) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Like) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Like) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Like) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Like) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Like) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Like) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Like) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Like) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Like) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Like) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Like) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Like) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Like) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Like) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Like) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Like) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Like) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Like) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Like) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Like) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Like) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Like) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Like) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Like) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Like) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Like) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Like) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Like) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Like) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Like) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Like) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Like) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Like) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Like) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Like) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Like) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Like) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Like) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Like) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Like) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Like) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Like) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Like) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Like) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Like) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Like) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Like) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Like) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Like) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Like) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Like) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Like) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Like) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Like) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Like) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Like) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Like) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Like) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Like) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Like) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Like) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Like) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Like) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Like) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Like) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is offering the object. If specified, the target indicates the entity to which the object is being offered. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Offer struct {
	// The raw type from the vocab package
	raw *vocab.Offer
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Offer) Raw() (n *vocab.Offer) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Offer) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Offer) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Offer) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Offer) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Offer) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Offer) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Offer) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Offer) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Offer) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Offer) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Offer) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Offer) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Offer) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Offer) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Offer) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Offer) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Offer) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Offer) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Offer) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Offer) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Offer) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Offer) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Offer) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Offer) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Offer) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Offer) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Offer) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Offer) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Offer) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Offer) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Offer) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Offer) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Offer) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Offer) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Offer) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Offer) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Offer) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Offer) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Offer) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Offer) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Offer) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Offer) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Offer) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Offer) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Offer) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Offer) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Offer) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Offer) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Offer) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Offer) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Offer) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Offer) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Offer) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Offer) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Offer) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Offer) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Offer) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Offer) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Offer) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Offer) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Offer) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Offer) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Offer) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Offer) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Offer) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Offer) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Offer) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Offer) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Offer) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Offer) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Offer) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Offer) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Offer) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Offer) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Offer) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Offer) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Offer) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Offer) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Offer) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Offer) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Offer) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Offer) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Offer) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Offer) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Offer) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Offer) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Offer) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Offer) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Offer) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Offer) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Offer) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Offer) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Offer) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Offer) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Offer) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Offer) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Offer) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Offer) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Offer) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Offer) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Offer) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Offer) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Offer) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Offer) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Offer) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Offer) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Offer) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Offer) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Offer) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Offer) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Offer) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Offer) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Offer) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Offer) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Offer) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Offer) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Offer) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Offer) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Offer) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A specialization of Offer in which the actor is extending an invitation for the object to the target. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Invite struct {
	// The raw type from the vocab package
	raw *vocab.Invite
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Invite) Raw() (n *vocab.Invite) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Invite) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Invite) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Invite) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Invite) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Invite) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Invite) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Invite) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Invite) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Invite) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Invite) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Invite) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Invite) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Invite) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Invite) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Invite) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Invite) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Invite) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Invite) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Invite) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Invite) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Invite) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Invite) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Invite) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Invite) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Invite) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Invite) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Invite) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Invite) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Invite) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Invite) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Invite) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Invite) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Invite) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Invite) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Invite) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Invite) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Invite) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Invite) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Invite) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Invite) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Invite) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Invite) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Invite) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Invite) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Invite) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Invite) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Invite) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Invite) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Invite) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Invite) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Invite) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Invite) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Invite) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Invite) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Invite) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Invite) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Invite) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Invite) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Invite) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Invite) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Invite) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Invite) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Invite) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Invite) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Invite) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Invite) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Invite) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Invite) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Invite) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Invite) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Invite) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Invite) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Invite) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Invite) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Invite) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Invite) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Invite) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Invite) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Invite) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Invite) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Invite) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Invite) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Invite) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Invite) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Invite) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Invite) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Invite) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Invite) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Invite) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Invite) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Invite) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Invite) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Invite) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Invite) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Invite) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Invite) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Invite) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Invite) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Invite) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Invite) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Invite) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Invite) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Invite) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Invite) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Invite) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Invite) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Invite) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Invite) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Invite) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Invite) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Invite) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Invite) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Invite) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Invite) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Invite) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Invite) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Invite) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Invite) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Invite) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is rejecting the object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Reject struct {
	// The raw type from the vocab package
	raw *vocab.Reject
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Reject) Raw() (n *vocab.Reject) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Reject) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Reject) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Reject) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Reject) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Reject) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Reject) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Reject) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Reject) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Reject) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Reject) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Reject) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Reject) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Reject) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Reject) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Reject) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Reject) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Reject) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Reject) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Reject) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Reject) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Reject) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Reject) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Reject) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Reject) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Reject) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Reject) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Reject) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Reject) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Reject) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Reject) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Reject) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Reject) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Reject) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Reject) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Reject) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Reject) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Reject) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Reject) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Reject) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Reject) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Reject) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Reject) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Reject) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Reject) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Reject) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Reject) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Reject) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Reject) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Reject) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Reject) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Reject) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Reject) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Reject) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Reject) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Reject) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Reject) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Reject) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Reject) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Reject) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Reject) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Reject) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Reject) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Reject) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Reject) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Reject) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Reject) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Reject) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Reject) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Reject) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Reject) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Reject) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Reject) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Reject) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Reject) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Reject) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Reject) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Reject) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Reject) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Reject) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Reject) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Reject) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Reject) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Reject) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Reject) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Reject) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Reject) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Reject) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Reject) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Reject) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Reject) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Reject) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Reject) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Reject) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Reject) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Reject) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Reject) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Reject) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Reject) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Reject) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Reject) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Reject) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Reject) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Reject) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Reject) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Reject) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Reject) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Reject) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Reject) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Reject) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Reject) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Reject) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Reject) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Reject) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Reject) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Reject) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Reject) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Reject) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Reject) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Reject) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A specialization of Reject in which the rejection is considered tentative. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type TentativeReject struct {
	// The raw type from the vocab package
	raw *vocab.TentativeReject
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *TentativeReject) Raw() (n *vocab.TentativeReject) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *TentativeReject) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *TentativeReject) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *TentativeReject) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *TentativeReject) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *TentativeReject) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *TentativeReject) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *TentativeReject) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *TentativeReject) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *TentativeReject) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *TentativeReject) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *TentativeReject) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *TentativeReject) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *TentativeReject) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *TentativeReject) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *TentativeReject) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *TentativeReject) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *TentativeReject) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *TentativeReject) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *TentativeReject) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *TentativeReject) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *TentativeReject) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *TentativeReject) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *TentativeReject) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *TentativeReject) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *TentativeReject) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *TentativeReject) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *TentativeReject) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *TentativeReject) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *TentativeReject) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *TentativeReject) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *TentativeReject) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *TentativeReject) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeReject) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *TentativeReject) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *TentativeReject) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *TentativeReject) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *TentativeReject) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *TentativeReject) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *TentativeReject) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *TentativeReject) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *TentativeReject) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeReject) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *TentativeReject) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *TentativeReject) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *TentativeReject) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *TentativeReject) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *TentativeReject) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *TentativeReject) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *TentativeReject) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *TentativeReject) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *TentativeReject) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *TentativeReject) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *TentativeReject) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *TentativeReject) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *TentativeReject) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *TentativeReject) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *TentativeReject) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *TentativeReject) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *TentativeReject) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *TentativeReject) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *TentativeReject) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *TentativeReject) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *TentativeReject) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *TentativeReject) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *TentativeReject) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *TentativeReject) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *TentativeReject) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *TentativeReject) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *TentativeReject) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *TentativeReject) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeReject) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *TentativeReject) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *TentativeReject) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *TentativeReject) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *TentativeReject) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *TentativeReject) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *TentativeReject) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *TentativeReject) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *TentativeReject) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *TentativeReject) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *TentativeReject) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *TentativeReject) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *TentativeReject) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *TentativeReject) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *TentativeReject) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *TentativeReject) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *TentativeReject) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *TentativeReject) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *TentativeReject) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *TentativeReject) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *TentativeReject) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *TentativeReject) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *TentativeReject) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *TentativeReject) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *TentativeReject) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *TentativeReject) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *TentativeReject) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *TentativeReject) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *TentativeReject) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *TentativeReject) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *TentativeReject) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *TentativeReject) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *TentativeReject) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *TentativeReject) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *TentativeReject) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *TentativeReject) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *TentativeReject) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *TentativeReject) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *TentativeReject) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *TentativeReject) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *TentativeReject) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *TentativeReject) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *TentativeReject) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *TentativeReject) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *TentativeReject) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *TentativeReject) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *TentativeReject) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *TentativeReject) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *TentativeReject) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is removing the object. If specified, the origin indicates the context from which the object is being removed. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Remove struct {
	// The raw type from the vocab package
	raw *vocab.Remove
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Remove) Raw() (n *vocab.Remove) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Remove) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Remove) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Remove) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Remove) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Remove) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Remove) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Remove) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Remove) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Remove) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Remove) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Remove) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Remove) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Remove) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Remove) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Remove) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Remove) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Remove) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Remove) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Remove) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Remove) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Remove) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Remove) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Remove) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Remove) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Remove) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Remove) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Remove) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Remove) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Remove) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Remove) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Remove) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Remove) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Remove) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Remove) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Remove) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Remove) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Remove) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Remove) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Remove) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Remove) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Remove) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Remove) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Remove) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Remove) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Remove) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Remove) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Remove) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Remove) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Remove) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Remove) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Remove) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Remove) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Remove) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Remove) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Remove) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Remove) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Remove) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Remove) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Remove) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Remove) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Remove) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Remove) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Remove) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Remove) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Remove) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Remove) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Remove) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Remove) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Remove) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Remove) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Remove) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Remove) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Remove) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Remove) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Remove) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Remove) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Remove) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Remove) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Remove) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Remove) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Remove) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Remove) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Remove) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Remove) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Remove) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Remove) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Remove) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Remove) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Remove) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Remove) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Remove) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Remove) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Remove) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Remove) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Remove) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Remove) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Remove) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Remove) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Remove) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Remove) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Remove) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Remove) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Remove) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Remove) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Remove) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Remove) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Remove) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Remove) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Remove) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Remove) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Remove) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Remove) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Remove) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Remove) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Remove) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Remove) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Remove) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Remove) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Remove) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is undoing the object. In most cases, the object will be an Activity describing some previously performed action (for instance, a person may have previously "liked" an article but, for whatever reason, might choose to undo that like at some later point in time). The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Undo struct {
	// The raw type from the vocab package
	raw *vocab.Undo
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Undo) Raw() (n *vocab.Undo) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Undo) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Undo) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Undo) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Undo) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Undo) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Undo) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Undo) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Undo) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Undo) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Undo) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Undo) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Undo) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Undo) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Undo) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Undo) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Undo) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Undo) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Undo) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Undo) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Undo) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Undo) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Undo) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Undo) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Undo) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Undo) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Undo) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Undo) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Undo) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Undo) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Undo) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Undo) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Undo) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Undo) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Undo) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Undo) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Undo) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Undo) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Undo) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Undo) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Undo) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Undo) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Undo) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Undo) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Undo) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Undo) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Undo) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Undo) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Undo) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Undo) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Undo) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Undo) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Undo) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Undo) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Undo) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Undo) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Undo) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Undo) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Undo) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Undo) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Undo) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Undo) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Undo) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Undo) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Undo) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Undo) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Undo) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Undo) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Undo) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Undo) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Undo) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Undo) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Undo) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Undo) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Undo) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Undo) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Undo) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Undo) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Undo) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Undo) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Undo) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Undo) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Undo) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Undo) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Undo) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Undo) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Undo) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Undo) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Undo) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Undo) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Undo) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Undo) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Undo) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Undo) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Undo) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Undo) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Undo) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Undo) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Undo) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Undo) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Undo) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Undo) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Undo) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Undo) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Undo) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Undo) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Undo) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Undo) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Undo) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Undo) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Undo) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Undo) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Undo) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Undo) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Undo) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Undo) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Undo) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Undo) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Undo) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Undo) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has updated the object. Note, however, that this vocabulary does not define a mechanism for describing the actual set of modifications made to object. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Update struct {
	// The raw type from the vocab package
	raw *vocab.Update
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Update) Raw() (n *vocab.Update) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Update) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Update) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Update) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Update) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Update) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Update) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Update) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Update) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Update) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Update) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Update) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Update) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Update) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Update) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Update) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Update) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Update) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Update) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Update) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Update) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Update) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Update) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Update) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Update) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Update) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Update) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Update) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Update) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Update) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Update) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Update) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Update) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Update) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Update) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Update) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Update) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Update) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Update) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Update) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Update) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Update) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Update) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Update) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Update) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Update) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Update) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Update) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Update) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Update) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Update) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Update) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Update) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Update) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Update) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Update) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Update) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Update) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Update) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Update) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Update) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Update) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Update) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Update) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Update) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Update) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Update) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Update) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Update) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Update) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Update) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Update) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Update) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Update) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Update) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Update) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Update) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Update) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Update) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Update) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Update) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Update) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Update) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Update) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Update) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Update) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Update) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Update) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Update) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Update) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Update) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Update) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Update) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Update) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Update) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Update) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Update) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Update) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Update) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Update) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Update) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Update) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Update) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Update) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Update) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Update) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Update) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Update) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Update) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Update) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Update) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Update) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Update) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Update) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Update) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Update) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Update) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Update) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Update) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Update) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has viewed the object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type View struct {
	// The raw type from the vocab package
	raw *vocab.View
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *View) Raw() (n *vocab.View) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *View) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *View) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *View) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *View) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *View) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *View) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *View) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *View) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *View) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *View) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *View) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *View) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *View) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *View) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *View) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *View) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *View) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *View) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *View) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *View) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *View) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *View) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *View) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *View) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *View) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *View) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *View) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *View) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *View) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *View) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *View) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *View) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *View) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *View) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *View) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *View) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *View) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *View) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *View) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *View) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *View) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *View) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *View) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *View) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *View) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *View) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *View) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *View) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *View) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *View) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *View) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *View) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *View) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *View) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *View) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *View) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *View) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *View) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *View) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *View) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *View) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *View) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *View) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *View) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *View) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *View) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *View) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *View) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *View) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *View) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *View) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *View) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *View) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *View) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *View) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *View) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *View) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *View) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *View) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *View) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *View) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *View) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *View) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *View) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *View) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *View) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *View) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *View) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *View) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *View) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *View) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *View) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *View) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *View) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *View) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *View) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *View) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *View) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *View) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *View) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *View) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *View) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *View) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *View) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *View) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *View) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *View) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *View) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *View) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *View) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *View) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *View) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *View) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *View) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *View) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *View) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *View) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *View) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *View) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has listened to the object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Listen struct {
	// The raw type from the vocab package
	raw *vocab.Listen
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Listen) Raw() (n *vocab.Listen) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Listen) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Listen) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Listen) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Listen) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Listen) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Listen) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Listen) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Listen) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Listen) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Listen) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Listen) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Listen) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Listen) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Listen) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Listen) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Listen) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Listen) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Listen) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Listen) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Listen) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Listen) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Listen) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Listen) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Listen) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Listen) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Listen) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Listen) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Listen) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Listen) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Listen) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Listen) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Listen) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Listen) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Listen) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Listen) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Listen) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Listen) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Listen) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Listen) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Listen) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Listen) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Listen) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Listen) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Listen) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Listen) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Listen) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Listen) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Listen) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Listen) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Listen) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Listen) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Listen) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Listen) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Listen) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Listen) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Listen) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Listen) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Listen) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Listen) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Listen) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Listen) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Listen) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Listen) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Listen) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Listen) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Listen) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Listen) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Listen) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Listen) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Listen) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Listen) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Listen) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Listen) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Listen) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Listen) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Listen) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Listen) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Listen) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Listen) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Listen) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Listen) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Listen) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Listen) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Listen) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Listen) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Listen) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Listen) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Listen) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Listen) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Listen) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Listen) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Listen) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Listen) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Listen) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Listen) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Listen) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Listen) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Listen) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Listen) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Listen) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Listen) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Listen) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Listen) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Listen) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Listen) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Listen) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Listen) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Listen) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Listen) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Listen) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Listen) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Listen) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Listen) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Listen) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Listen) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Listen) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Listen) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Listen) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Listen) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has read the object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Read struct {
	// The raw type from the vocab package
	raw *vocab.Read
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Read) Raw() (n *vocab.Read) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Read) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Read) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Read) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Read) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Read) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Read) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Read) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Read) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Read) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Read) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Read) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Read) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Read) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Read) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Read) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Read) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Read) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Read) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Read) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Read) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Read) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Read) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Read) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Read) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Read) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Read) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Read) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Read) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Read) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Read) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Read) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Read) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Read) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Read) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Read) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Read) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Read) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Read) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Read) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Read) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Read) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Read) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Read) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Read) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Read) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Read) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Read) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Read) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Read) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Read) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Read) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Read) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Read) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Read) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Read) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Read) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Read) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Read) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Read) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Read) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Read) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Read) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Read) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Read) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Read) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Read) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Read) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Read) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Read) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Read) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Read) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Read) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Read) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Read) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Read) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Read) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Read) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Read) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Read) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Read) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Read) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Read) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Read) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Read) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Read) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Read) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Read) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Read) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Read) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Read) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Read) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Read) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Read) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Read) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Read) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Read) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Read) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Read) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Read) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Read) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Read) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Read) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Read) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Read) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Read) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Read) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Read) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Read) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Read) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Read) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Read) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Read) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Read) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Read) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Read) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Read) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Read) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Read) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Read) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor has moved object from origin to target. If the origin or target are not specified, either can be determined by context. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Move struct {
	// The raw type from the vocab package
	raw *vocab.Move
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Move) Raw() (n *vocab.Move) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Move) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Move) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Move) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Move) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Move) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Move) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Move) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Move) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Move) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Move) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Move) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Move) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Move) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Move) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Move) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Move) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Move) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Move) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Move) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Move) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Move) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Move) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Move) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Move) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Move) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Move) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Move) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Move) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Move) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Move) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Move) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Move) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Move) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Move) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Move) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Move) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Move) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Move) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Move) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Move) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Move) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Move) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Move) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Move) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Move) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Move) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Move) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Move) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Move) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Move) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Move) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Move) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Move) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Move) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Move) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Move) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Move) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Move) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Move) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Move) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Move) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Move) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Move) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Move) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Move) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Move) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Move) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Move) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Move) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Move) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Move) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Move) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Move) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Move) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Move) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Move) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Move) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Move) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Move) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Move) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Move) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Move) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Move) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Move) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Move) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Move) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Move) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Move) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Move) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Move) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Move) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Move) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Move) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Move) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Move) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Move) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Move) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Move) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Move) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Move) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Move) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Move) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Move) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Move) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Move) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Move) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Move) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Move) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Move) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Move) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Move) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Move) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Move) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Move) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Move) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Move) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Move) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Move) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Move) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is traveling to target from origin. Travel is an IntransitiveObject whose actor specifies the direct object. If the target or origin are not specified, either can be determined by context. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Travel struct {
	// The raw type from the vocab package
	raw *vocab.Travel
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Travel) Raw() (n *vocab.Travel) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Travel) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Travel) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Travel) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Travel) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Travel) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Travel) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Travel) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Travel) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Travel) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Travel) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Travel) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Travel) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Travel) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Travel) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Travel) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Travel) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Travel) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Travel) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Travel) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Travel) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Travel) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Travel) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Travel) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Travel) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Travel) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Travel) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Travel) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Travel) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Travel) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Travel) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Travel) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Travel) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Travel) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Travel) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Travel) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Travel) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Travel) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Travel) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Travel) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Travel) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Travel) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Travel) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Travel) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Travel) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Travel) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Travel) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Travel) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Travel) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Travel) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Travel) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Travel) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Travel) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Travel) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Travel) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Travel) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Travel) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Travel) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Travel) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Travel) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Travel) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Travel) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Travel) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Travel) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Travel) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Travel) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Travel) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Travel) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Travel) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Travel) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Travel) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Travel) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Travel) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Travel) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Travel) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Travel) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Travel) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Travel) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Travel) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Travel) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Travel) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Travel) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Travel) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Travel) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Travel) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Travel) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Travel) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Travel) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Travel) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Travel) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Travel) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Travel) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Travel) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Travel) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Travel) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Travel) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Travel) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Travel) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Travel) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Travel) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Travel) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Travel) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Travel) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Travel) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Travel) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Travel) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Travel) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Travel) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Travel) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Travel) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Travel) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Travel) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Travel) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Travel) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Travel) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Travel) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Travel) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is calling the target's attention the object. The origin typically has no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Announce struct {
	// The raw type from the vocab package
	raw *vocab.Announce
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Announce) Raw() (n *vocab.Announce) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Announce) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Announce) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Announce) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Announce) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Announce) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Announce) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Announce) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Announce) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Announce) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Announce) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Announce) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Announce) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Announce) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Announce) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Announce) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Announce) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Announce) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Announce) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Announce) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Announce) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Announce) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Announce) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Announce) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Announce) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Announce) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Announce) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Announce) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Announce) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Announce) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Announce) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Announce) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Announce) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Announce) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Announce) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Announce) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Announce) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Announce) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Announce) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Announce) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Announce) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Announce) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Announce) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Announce) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Announce) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Announce) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Announce) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Announce) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Announce) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Announce) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Announce) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Announce) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Announce) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Announce) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Announce) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Announce) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Announce) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Announce) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Announce) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Announce) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Announce) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Announce) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Announce) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Announce) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Announce) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Announce) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Announce) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Announce) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Announce) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Announce) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Announce) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Announce) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Announce) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Announce) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Announce) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Announce) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Announce) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Announce) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Announce) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Announce) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Announce) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Announce) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Announce) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Announce) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Announce) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Announce) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Announce) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Announce) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Announce) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Announce) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Announce) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Announce) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Announce) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Announce) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Announce) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Announce) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Announce) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Announce) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Announce) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Announce) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Announce) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Announce) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Announce) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Announce) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Announce) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Announce) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Announce) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Announce) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Announce) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Announce) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Announce) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Announce) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Announce) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Announce) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Announce) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Announce) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Announce) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Announce) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Announce) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Announce) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is blocking the object. Blocking is a stronger form of Ignore. The typical use is to support social systems that allow one user to block activities or content of other users. The target and origin typically have no defined meaning. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Block struct {
	// The raw type from the vocab package
	raw *vocab.Block
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Block) Raw() (n *vocab.Block) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Block) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Block) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Block) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Block) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Block) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Block) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Block) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Block) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Block) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Block) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Block) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Block) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Block) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Block) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Block) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Block) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Block) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Block) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Block) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Block) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Block) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Block) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Block) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Block) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Block) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Block) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Block) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Block) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Block) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Block) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Block) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Block) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Block) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Block) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Block) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Block) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Block) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Block) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Block) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Block) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Block) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Block) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Block) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Block) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Block) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Block) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Block) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Block) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Block) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Block) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Block) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Block) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Block) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Block) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Block) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Block) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Block) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Block) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Block) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Block) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Block) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Block) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Block) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Block) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Block) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Block) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Block) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Block) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Block) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Block) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Block) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Block) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Block) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Block) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Block) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Block) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Block) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Block) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Block) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Block) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Block) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Block) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Block) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Block) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Block) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Block) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Block) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Block) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Block) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Block) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Block) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Block) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Block) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Block) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Block) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Block) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Block) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Block) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Block) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Block) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Block) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Block) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Block) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Block) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Block) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Block) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Block) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Block) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Block) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Block) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Block) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Block) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Block) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Block) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Block) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Block) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Block) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Block) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Block) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor is "flagging" the object. Flagging is defined in the sense common to many social platforms as reporting content as being inappropriate for any number of reasons. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Flag struct {
	// The raw type from the vocab package
	raw *vocab.Flag
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Flag) Raw() (n *vocab.Flag) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Flag) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Flag) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Flag) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Flag) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Flag) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Flag) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Flag) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Flag) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Flag) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Flag) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Flag) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Flag) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Flag) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Flag) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Flag) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Flag) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Flag) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Flag) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Flag) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Flag) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Flag) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Flag) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Flag) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Flag) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Flag) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Flag) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Flag) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Flag) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Flag) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Flag) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Flag) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Flag) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Flag) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Flag) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Flag) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Flag) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Flag) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Flag) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Flag) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Flag) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Flag) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Flag) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Flag) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Flag) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Flag) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Flag) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Flag) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Flag) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Flag) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Flag) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Flag) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Flag) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Flag) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Flag) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Flag) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Flag) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Flag) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Flag) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Flag) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Flag) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Flag) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Flag) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Flag) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Flag) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Flag) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Flag) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Flag) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Flag) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Flag) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Flag) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Flag) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Flag) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Flag) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Flag) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Flag) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Flag) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Flag) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Flag) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Flag) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Flag) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Flag) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Flag) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Flag) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Flag) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Flag) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Flag) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Flag) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Flag) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Flag) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Flag) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Flag) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Flag) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Flag) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Flag) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Flag) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Flag) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Flag) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Flag) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Flag) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Flag) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Flag) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Flag) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Flag) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Flag) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Flag) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Flag) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Flag) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Flag) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Flag) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Flag) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Flag) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Flag) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Flag) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Flag) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Flag) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Flag) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Flag) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Flag) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Flag) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Indicates that the actor dislikes the object. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Dislike struct {
	// The raw type from the vocab package
	raw *vocab.Dislike
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Dislike) Raw() (n *vocab.Dislike) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Dislike) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Dislike) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Dislike) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Dislike) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Dislike) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Dislike) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Dislike) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Dislike) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Dislike) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Dislike) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Dislike) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Dislike) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Dislike) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Dislike) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Dislike) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Dislike) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Dislike) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Dislike) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Dislike) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Dislike) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Dislike) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Dislike) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Dislike) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Dislike) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Dislike) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Dislike) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Dislike) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Dislike) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Dislike) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Dislike) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Dislike) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Dislike) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Dislike) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Dislike) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Dislike) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Dislike) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Dislike) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Dislike) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Dislike) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Dislike) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Dislike) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Dislike) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Dislike) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Dislike) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Dislike) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Dislike) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Dislike) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Dislike) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Dislike) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Dislike) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Dislike) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Dislike) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Dislike) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Dislike) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Dislike) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Dislike) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Dislike) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Dislike) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Dislike) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Dislike) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Dislike) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Dislike) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Dislike) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Dislike) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Dislike) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Dislike) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Dislike) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Dislike) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Dislike) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Dislike) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Dislike) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Dislike) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Dislike) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Dislike) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Dislike) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Dislike) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Dislike) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Dislike) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Dislike) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Dislike) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Dislike) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Dislike) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Dislike) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Dislike) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Dislike) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Dislike) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Dislike) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Dislike) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Dislike) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Dislike) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Dislike) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Dislike) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Dislike) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Dislike) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Dislike) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Dislike) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Dislike) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Dislike) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Dislike) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Dislike) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Dislike) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Dislike) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Dislike) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Dislike) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Dislike) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Dislike) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Dislike) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Dislike) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Dislike) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Dislike) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Dislike) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Dislike) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Dislike) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Dislike) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Dislike) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Dislike) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Dislike) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Dislike) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Dislike) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a question being asked. Question objects are an extension of IntransitiveActivity. That is, the Question object is an Activity, but the direct object is the question itself and therefore it would not contain an object property. Either of the anyOf and oneOf properties may be used to express possible answers, but a Question object must not have both properties. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Question struct {
	// The raw type from the vocab package
	raw *vocab.Question
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Question) Raw() (n *vocab.Question) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Question) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenOneOf returns the number of values this property contains. Each index be used with HasOneOf to determine if ResolveOneOf is safe to call or if raw handling would be needed.%!(EXTRA string=oneOf)
func (t *Question) LenOneOf() (idx int) {
	return t.raw.OneOfLen()

}

// ResolveOneOf passes the actual concrete type to the resolver for handing property oneOf. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveOneOf(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOneOfObject(idx) {
		handled, err = r.dispatch(t.raw.GetOneOfObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOneOfLink(idx) {
		handled, err = r.dispatch(t.raw.GetOneOfLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOneOfIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOneOf returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasOneOf(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOneOfObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOneOfLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOneOfIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOneOf adds an 'Object' typed value.
func (t *Question) AddOneOf(i vocab.ObjectType) {
	t.raw.AddOneOfObject(i)

}

// SetOneOfLink adds a 'Link' typed value.
func (t *Question) SetOneOfLink(i vocab.LinkType) {
	t.raw.AddOneOfLink(i)

}

// LenAnyOf returns the number of values this property contains. Each index be used with HasAnyOf to determine if ResolveAnyOf is safe to call or if raw handling would be needed.%!(EXTRA string=anyOf)
func (t *Question) LenAnyOf() (idx int) {
	return t.raw.AnyOfLen()

}

// ResolveAnyOf passes the actual concrete type to the resolver for handing property anyOf. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveAnyOf(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAnyOfObject(idx) {
		handled, err = r.dispatch(t.raw.GetAnyOfObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAnyOfLink(idx) {
		handled, err = r.dispatch(t.raw.GetAnyOfLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAnyOfIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAnyOf returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasAnyOf(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAnyOfObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAnyOfLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAnyOfIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAnyOf adds an 'Object' typed value.
func (t *Question) AddAnyOf(i vocab.ObjectType) {
	t.raw.AddAnyOfObject(i)

}

// SetAnyOfLink adds a 'Link' typed value.
func (t *Question) SetAnyOfLink(i vocab.LinkType) {
	t.raw.AddAnyOfLink(i)

}

// LenClosed returns the number of values this property contains. Each index be used with HasClosed to determine if GetClosed is safe to call or if raw handling would be needed.%!(EXTRA string=closed)
func (t *Question) LenClosed() (idx int) {
	return t.raw.ClosedLen()

}

// GetClosed attempts to get this 'closed' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetClosed(idx int) (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsClosedDateTime(idx) {
		k = t.raw.GetClosedDateTime(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsClosedBoolean(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsClosedObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsClosedLink(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsClosedIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddClosed appends the value for property 'closed'.
func (t *Question) AddClosed(k time.Time) {
	t.raw.AddClosedDateTime(k)

}

// RemoveClosed deletes the value from the specified index for property 'closed'.
func (t *Question) RemoveClosed(idx int) {
	t.raw.RemoveClosedDateTime(idx)

}

// HasClosed returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasClosed(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsClosedDateTime(idx) {
		p = ConvenientPresence
	} else if t.raw.IsClosedBoolean(idx) {
		p = RawPresence
	} else if t.raw.IsClosedObject(idx) {
		p = RawPresence
	} else if t.raw.IsClosedLink(idx) {
		p = RawPresence
	} else if t.raw.IsClosedIRI(idx) {
		p = RawPresence
	}
	return

}

// LenActor returns the number of values this property contains. Each index be used with HasActor to determine if GetActor is safe to call or if raw handling would be needed.%!(EXTRA string=actor)
func (t *Question) LenActor() (idx int) {
	return t.raw.ActorLen()

}

// GetActor attempts to get this 'actor' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetActor(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsActorIRI(idx) {
		k = t.raw.GetActorIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsActorObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsActorLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddActor appends the value for property 'actor'.
func (t *Question) AddActor(k url.URL) {
	t.raw.AddActorIRI(k)

}

// RemoveActor deletes the value from the specified index for property 'actor'.
func (t *Question) RemoveActor(idx int) {
	t.raw.RemoveActorIRI(idx)

}

// HasActor returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasActor(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsActorIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsActorLink(idx) {
		p = RawPresence
	} else if t.raw.IsActorIRI(idx) {
		p = RawPresence
	}
	return

}

// LenTarget returns the number of values this property contains. Each index be used with HasTarget to determine if GetTarget is safe to call or if raw handling would be needed.%!(EXTRA string=target)
func (t *Question) LenTarget() (idx int) {
	return t.raw.TargetLen()

}

// GetTarget attempts to get this 'target' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetTarget(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsTargetIRI(idx) {
		k = t.raw.GetTargetIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsTargetObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsTargetLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTarget appends the value for property 'target'.
func (t *Question) AddTarget(k url.URL) {
	t.raw.AddTargetIRI(k)

}

// RemoveTarget deletes the value from the specified index for property 'target'.
func (t *Question) RemoveTarget(idx int) {
	t.raw.RemoveTargetIRI(idx)

}

// HasTarget returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasTarget(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTargetIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTargetLink(idx) {
		p = RawPresence
	} else if t.raw.IsTargetIRI(idx) {
		p = RawPresence
	}
	return

}

// LenResult returns the number of values this property contains. Each index be used with HasResult to determine if ResolveResult is safe to call or if raw handling would be needed.%!(EXTRA string=result)
func (t *Question) LenResult() (idx int) {
	return t.raw.ResultLen()

}

// ResolveResult passes the actual concrete type to the resolver for handing property result. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveResult(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsResultObject(idx) {
		handled, err = r.dispatch(t.raw.GetResultObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultLink(idx) {
		handled, err = r.dispatch(t.raw.GetResultLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsResultIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasResult returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasResult(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsResultObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsResultIRI(idx) {
		p = RawPresence
	}
	return

}

// AddResult adds an 'Object' typed value.
func (t *Question) AddResult(i vocab.ObjectType) {
	t.raw.AddResultObject(i)

}

// SetResultLink adds a 'Link' typed value.
func (t *Question) SetResultLink(i vocab.LinkType) {
	t.raw.AddResultLink(i)

}

// LenOrigin returns the number of values this property contains. Each index be used with HasOrigin to determine if ResolveOrigin is safe to call or if raw handling would be needed.%!(EXTRA string=origin)
func (t *Question) LenOrigin() (idx int) {
	return t.raw.OriginLen()

}

// ResolveOrigin passes the actual concrete type to the resolver for handing property origin. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveOrigin(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsOriginObject(idx) {
		handled, err = r.dispatch(t.raw.GetOriginObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginLink(idx) {
		handled, err = r.dispatch(t.raw.GetOriginLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsOriginIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasOrigin returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasOrigin(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsOriginObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsOriginIRI(idx) {
		p = RawPresence
	}
	return

}

// AddOrigin adds an 'Object' typed value.
func (t *Question) AddOrigin(i vocab.ObjectType) {
	t.raw.AddOriginObject(i)

}

// SetOriginLink adds a 'Link' typed value.
func (t *Question) SetOriginLink(i vocab.LinkType) {
	t.raw.AddOriginLink(i)

}

// LenInstrument returns the number of values this property contains. Each index be used with HasInstrument to determine if ResolveInstrument is safe to call or if raw handling would be needed.%!(EXTRA string=instrument)
func (t *Question) LenInstrument() (idx int) {
	return t.raw.InstrumentLen()

}

// ResolveInstrument passes the actual concrete type to the resolver for handing property instrument. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveInstrument(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsInstrumentObject(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentLink(idx) {
		handled, err = r.dispatch(t.raw.GetInstrumentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsInstrumentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasInstrument returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasInstrument(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInstrumentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInstrumentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddInstrument adds an 'Object' typed value.
func (t *Question) AddInstrument(i vocab.ObjectType) {
	t.raw.AddInstrumentObject(i)

}

// SetInstrumentLink adds a 'Link' typed value.
func (t *Question) SetInstrumentLink(i vocab.LinkType) {
	t.raw.AddInstrumentLink(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Question) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Question) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Question) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Question) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Question) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Question) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Question) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Question) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Question) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Question) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Question) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Question) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Question) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Question) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Question) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Question) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Question) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Question) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Question) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Question) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Question) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Question) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Question) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Question) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Question) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Question) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Question) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Question) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Question) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Question) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Question) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Question) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Question) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Question) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Question) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Question) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Question) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Question) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Question) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Question) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Question) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Question) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Question) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Question) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Question) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Question) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Question) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Question) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Question) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Question) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Question) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Question) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Question) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Question) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Question) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Question) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Question) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Question) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Question) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Question) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Question) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Question) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Question) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Question) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Question) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Question) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Question) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Question) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Question) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Question) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Question) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Question) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Question) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Question) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Question) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Question) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Question) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Question) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Question) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Question) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Question) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Question) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Question) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Question) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Question) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Question) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Question) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Question) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Question) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Question) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Question) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Question) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Question) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Question) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Question) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Question) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Question) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Question) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Question) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Question) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Describes a software application. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Application struct {
	// The raw type from the vocab package
	raw *vocab.Application
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Application) Raw() (n *vocab.Application) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Application) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Application) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Application) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Application) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Application) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Application) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Application) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Application) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Application) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Application) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Application) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Application) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Application) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Application) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Application) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Application) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Application) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Application) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Application) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Application) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Application) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Application) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Application) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Application) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Application) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Application) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Application) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Application) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Application) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Application) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Application) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Application) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Application) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Application) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Application) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Application) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Application) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Application) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Application) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Application) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Application) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Application) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Application) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Application) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Application) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Application) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Application) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Application) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Application) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Application) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Application) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Application) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Application) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Application) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Application) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Application) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Application) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Application) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Application) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Application) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Application) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Application) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Application) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Application) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Application) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Application) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Application) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Application) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Application) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Application) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Application) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Application) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Application) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Application) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Application) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Application) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Application) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Application) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Application) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Application) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Application) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Application) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Application) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Application) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Application) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Application) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Application) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Application) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Application) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Application) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Application) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Application) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Application) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Application) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Application) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Application) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Application) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Application) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Application) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Application) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Application) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a formal or informal collective of Actors. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Group struct {
	// The raw type from the vocab package
	raw *vocab.Group
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Group) Raw() (n *vocab.Group) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Group) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Group) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Group) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Group) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Group) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Group) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Group) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Group) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Group) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Group) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Group) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Group) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Group) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Group) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Group) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Group) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Group) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Group) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Group) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Group) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Group) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Group) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Group) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Group) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Group) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Group) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Group) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Group) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Group) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Group) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Group) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Group) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Group) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Group) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Group) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Group) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Group) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Group) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Group) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Group) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Group) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Group) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Group) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Group) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Group) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Group) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Group) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Group) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Group) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Group) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Group) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Group) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Group) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Group) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Group) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Group) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Group) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Group) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Group) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Group) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Group) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Group) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Group) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Group) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Group) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Group) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Group) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Group) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Group) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Group) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Group) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Group) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Group) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Group) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Group) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Group) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Group) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Group) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Group) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Group) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Group) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Group) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Group) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Group) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Group) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Group) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Group) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Group) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Group) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Group) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Group) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Group) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Group) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Group) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Group) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Group) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Group) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Group) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Group) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Group) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Group) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents an organization. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Organization struct {
	// The raw type from the vocab package
	raw *vocab.Organization
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Organization) Raw() (n *vocab.Organization) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Organization) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Organization) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Organization) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Organization) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Organization) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Organization) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Organization) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Organization) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Organization) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Organization) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Organization) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Organization) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Organization) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Organization) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Organization) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Organization) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Organization) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Organization) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Organization) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Organization) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Organization) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Organization) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Organization) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Organization) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Organization) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Organization) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Organization) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Organization) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Organization) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Organization) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Organization) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Organization) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Organization) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Organization) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Organization) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Organization) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Organization) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Organization) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Organization) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Organization) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Organization) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Organization) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Organization) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Organization) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Organization) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Organization) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Organization) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Organization) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Organization) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Organization) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Organization) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Organization) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Organization) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Organization) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Organization) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Organization) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Organization) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Organization) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Organization) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Organization) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Organization) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Organization) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Organization) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Organization) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Organization) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Organization) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Organization) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Organization) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Organization) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Organization) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Organization) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Organization) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Organization) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Organization) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Organization) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Organization) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Organization) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Organization) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Organization) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Organization) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Organization) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Organization) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Organization) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Organization) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Organization) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Organization) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Organization) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Organization) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Organization) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Organization) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Organization) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Organization) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Organization) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Organization) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Organization) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Organization) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Organization) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Organization) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Organization) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Organization) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Organization) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents an individual person. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Person struct {
	// The raw type from the vocab package
	raw *vocab.Person
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Person) Raw() (n *vocab.Person) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Person) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Person) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Person) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Person) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Person) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Person) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Person) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Person) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Person) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Person) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Person) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Person) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Person) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Person) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Person) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Person) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Person) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Person) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Person) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Person) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Person) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Person) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Person) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Person) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Person) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Person) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Person) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Person) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Person) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Person) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Person) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Person) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Person) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Person) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Person) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Person) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Person) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Person) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Person) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Person) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Person) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Person) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Person) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Person) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Person) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Person) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Person) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Person) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Person) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Person) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Person) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Person) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Person) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Person) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Person) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Person) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Person) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Person) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Person) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Person) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Person) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Person) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Person) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Person) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Person) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Person) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Person) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Person) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Person) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Person) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Person) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Person) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Person) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Person) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Person) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Person) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Person) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Person) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Person) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Person) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Person) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Person) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Person) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Person) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Person) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Person) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Person) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Person) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Person) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Person) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Person) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Person) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Person) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Person) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Person) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Person) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Person) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Person) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Person) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Person) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Person) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a service of any kind. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Service struct {
	// The raw type from the vocab package
	raw *vocab.Service
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Service) Raw() (n *vocab.Service) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Service) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Service) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Service) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Service) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Service) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Service) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Service) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Service) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Service) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Service) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Service) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Service) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Service) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Service) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Service) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Service) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Service) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Service) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Service) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Service) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Service) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Service) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Service) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Service) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Service) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Service) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Service) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Service) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Service) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Service) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Service) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Service) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Service) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Service) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Service) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Service) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Service) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Service) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Service) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Service) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Service) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Service) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Service) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Service) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Service) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Service) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Service) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Service) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Service) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Service) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Service) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Service) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Service) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Service) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Service) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Service) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Service) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Service) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Service) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Service) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Service) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Service) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Service) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Service) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Service) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Service) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Service) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Service) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Service) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Service) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Service) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Service) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Service) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Service) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Service) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Service) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Service) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Service) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Service) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Service) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Service) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Service) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Service) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Service) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Service) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Service) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Service) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Service) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Service) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Service) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Service) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Service) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Service) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Service) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Service) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Service) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Service) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Service) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Service) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Service) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Service) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Describes a relationship between two individuals. The subject and object properties are used to identify the connected individuals. See 5.2 Representing Relationships Between Entities for additional information. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Relationship struct {
	// The raw type from the vocab package
	raw *vocab.Relationship
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Relationship) Raw() (n *vocab.Relationship) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Relationship) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// ResolveSubject passes the actual concrete type to the resolver for handing property subject. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveSubject(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSubjectObject() {
		handled, err = r.dispatch(t.raw.GetSubjectObject())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSubjectLink() {
		handled, err = r.dispatch(t.raw.GetSubjectLink())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSubjectIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSubject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasSubject() (p Presence) {
	p = NoPresence
	if t.raw.IsSubjectObject() {
		p = ConvenientPresence
	} else if t.raw.IsSubjectLink() {
		p = ConvenientPresence
	} else if t.raw.IsSubjectIRI() {
		p = RawPresence
	}
	return

}

// SetSubject sets this value to be an 'Object' type.
func (t *Relationship) SetSubject(i vocab.ObjectType) {
	t.raw.SetSubjectObject(i)

}

// SetSubjectLink sets this value to be an 'Link' type.
func (t *Relationship) SetSubjectLink(i vocab.LinkType) {
	t.raw.SetSubjectLink(i)

}

// LenObject returns the number of values this property contains. Each index be used with HasObject to determine if ResolveObject is safe to call or if raw handling would be needed.%!(EXTRA string=object)
func (t *Relationship) LenObject() (idx int) {
	return t.raw.ObjectLen()

}

// ResolveObject passes the actual concrete type to the resolver for handing property object. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveObject(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsObject(idx) {
		handled, err = r.dispatch(t.raw.GetObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsObjectIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddObject appends the value for property 'object'.
func (t *Relationship) AddObject(i vocab.ObjectType) {
	t.raw.AddObject(i)

}

// RemoveObject deletes the value from the specified index for property 'object'.
func (t *Relationship) RemoveObject(idx int) {
	t.raw.RemoveObject(idx)

}

// HasObject returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasObject(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsObjectIRI(idx) {
		p = RawPresence
	}
	return

}

// ResolveRelationship passes the actual concrete type to the resolver for handing property relationship. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveRelationship(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsRelationship() {
		handled, err = r.dispatch(t.raw.GetRelationship())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRelationshipIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasRelationship returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasRelationship() (p Presence) {
	p = NoPresence
	if t.raw.IsRelationship() {
		p = ConvenientPresence
	} else if t.raw.IsRelationshipIRI() {
		p = RawPresence
	}
	return

}

// SetRelationship sets this value to be a 'Object' type.
func (t *Relationship) SetRelationship(i vocab.ObjectType) {
	t.raw.SetRelationship(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Relationship) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Relationship) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Relationship) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Relationship) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Relationship) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Relationship) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Relationship) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Relationship) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Relationship) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Relationship) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Relationship) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Relationship) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Relationship) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Relationship) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Relationship) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Relationship) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Relationship) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Relationship) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Relationship) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Relationship) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Relationship) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Relationship) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Relationship) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Relationship) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Relationship) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Relationship) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Relationship) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Relationship) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Relationship) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Relationship) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Relationship) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Relationship) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Relationship) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Relationship) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Relationship) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Relationship) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Relationship) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Relationship) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Relationship) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Relationship) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Relationship) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Relationship) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Relationship) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Relationship) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Relationship) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Relationship) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Relationship) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Relationship) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Relationship) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Relationship) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Relationship) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Relationship) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Relationship) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Relationship) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Relationship) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Relationship) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Relationship) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Relationship) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Relationship) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Relationship) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Relationship) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Relationship) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Relationship) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Relationship) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Relationship) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Relationship) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Relationship) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Relationship) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Relationship) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Relationship) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Relationship) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Relationship) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Relationship) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Relationship) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Relationship) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Relationship) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Relationship) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Relationship) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Relationship) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Relationship) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Relationship) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Relationship) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Relationship) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Relationship) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Relationship) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Relationship) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Relationship) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Relationship) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Relationship) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Relationship) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Relationship) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Relationship) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Relationship) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Relationship) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Relationship) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Relationship) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Relationship) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Relationship) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Relationship) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Relationship) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents any kind of multi-paragraph written work. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Article struct {
	// The raw type from the vocab package
	raw *vocab.Article
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Article) Raw() (n *vocab.Article) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Article) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Article) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Article) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Article) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Article) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Article) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Article) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Article) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Article) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Article) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Article) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Article) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Article) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Article) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Article) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Article) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Article) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Article) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Article) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Article) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Article) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Article) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Article) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Article) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Article) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Article) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Article) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Article) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Article) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Article) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Article) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Article) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Article) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Article) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Article) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Article) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Article) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Article) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Article) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Article) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Article) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Article) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Article) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Article) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Article) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Article) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Article) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Article) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Article) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Article) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Article) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Article) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Article) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Article) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Article) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Article) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Article) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Article) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Article) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Article) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Article) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Article) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Article) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Article) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Article) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Article) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Article) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Article) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Article) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Article) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Article) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Article) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Article) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Article) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Article) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Article) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Article) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Article) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Article) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Article) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Article) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Article) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Article) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Article) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Article) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Article) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Article) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Article) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Article) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Article) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Article) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Article) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Article) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Article) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Article) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Article) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Article) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Article) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Article) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Article) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Article) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a document of any kind. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Document struct {
	// The raw type from the vocab package
	raw *vocab.Document
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Document) Raw() (n *vocab.Document) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Document) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Document) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Document) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Document) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Document) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Document) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Document) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Document) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Document) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Document) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Document) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Document) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Document) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Document) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Document) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Document) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Document) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Document) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Document) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Document) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Document) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Document) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Document) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Document) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Document) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Document) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Document) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Document) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Document) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Document) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Document) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Document) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Document) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Document) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Document) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Document) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Document) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Document) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Document) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Document) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Document) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Document) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Document) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Document) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Document) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Document) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Document) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Document) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Document) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Document) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Document) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Document) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Document) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Document) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Document) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Document) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Document) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Document) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Document) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Document) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Document) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Document) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Document) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Document) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Document) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Document) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Document) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Document) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Document) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Document) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Document) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Document) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Document) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Document) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Document) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Document) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Document) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Document) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Document) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Document) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Document) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Document) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Document) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Document) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Document) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Document) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Document) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Document) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Document) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Document) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Document) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Document) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Document) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Document) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Document) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Document) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Document) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Document) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Document) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Document) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Document) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents an audio document of any kind. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Audio struct {
	// The raw type from the vocab package
	raw *vocab.Audio
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Audio) Raw() (n *vocab.Audio) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Audio) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Audio) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Audio) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Audio) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Audio) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Audio) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Audio) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Audio) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Audio) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Audio) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Audio) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Audio) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Audio) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Audio) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Audio) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Audio) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Audio) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Audio) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Audio) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Audio) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Audio) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Audio) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Audio) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Audio) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Audio) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Audio) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Audio) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Audio) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Audio) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Audio) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Audio) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Audio) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Audio) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Audio) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Audio) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Audio) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Audio) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Audio) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Audio) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Audio) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Audio) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Audio) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Audio) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Audio) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Audio) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Audio) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Audio) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Audio) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Audio) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Audio) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Audio) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Audio) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Audio) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Audio) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Audio) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Audio) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Audio) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Audio) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Audio) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Audio) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Audio) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Audio) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Audio) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Audio) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Audio) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Audio) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Audio) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Audio) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Audio) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Audio) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Audio) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Audio) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Audio) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Audio) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Audio) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Audio) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Audio) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Audio) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Audio) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Audio) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Audio) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Audio) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Audio) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Audio) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Audio) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Audio) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Audio) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Audio) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Audio) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Audio) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Audio) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Audio) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Audio) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Audio) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Audio) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Audio) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Audio) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Audio) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Audio) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Audio) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Audio) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// An image document of any kind This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Image struct {
	// The raw type from the vocab package
	raw *vocab.Image
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Image) Raw() (n *vocab.Image) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Image) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetHeight attempts to get this 'height' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetHeight() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsHeight() {
		k = t.raw.GetHeight()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsHeightIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasHeight returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasHeight() (p Presence) {
	p = NoPresence
	if t.raw.IsHeight() {
		p = ConvenientPresence
	} else if t.raw.IsHeightIRI() {
		p = RawPresence
	}
	return

}

// SetHeight sets the value for property 'height'.
func (t *Image) SetHeight(k int64) {
	t.raw.SetHeight(k)

}

// GetWidth attempts to get this 'width' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetWidth() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsWidth() {
		k = t.raw.GetWidth()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsWidthIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasWidth returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasWidth() (p Presence) {
	p = NoPresence
	if t.raw.IsWidth() {
		p = ConvenientPresence
	} else if t.raw.IsWidthIRI() {
		p = RawPresence
	}
	return

}

// SetWidth sets the value for property 'width'.
func (t *Image) SetWidth(k int64) {
	t.raw.SetWidth(k)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Image) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Image) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Image) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Image) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Image) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Image) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Image) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Image) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Image) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Image) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Image) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Image) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Image) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Image) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Image) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Image) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Image) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Image) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Image) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Image) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Image) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Image) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Image) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Image) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Image) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Image) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Image) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Image) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Image) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Image) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Image) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Image) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Image) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Image) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Image) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Image) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Image) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Image) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Image) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Image) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Image) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Image) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Image) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Image) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Image) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Image) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Image) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Image) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Image) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Image) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Image) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Image) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Image) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Image) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Image) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Image) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Image) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Image) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Image) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Image) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Image) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Image) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Image) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Image) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Image) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Image) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Image) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Image) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Image) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Image) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Image) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Image) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Image) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Image) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Image) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Image) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Image) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Image) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Image) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Image) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Image) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Image) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Image) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Image) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Image) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Image) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Image) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Image) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Image) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Image) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Image) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Image) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Image) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Image) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Image) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Image) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Image) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Image) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Image) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Image) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a video document of any kind. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Video struct {
	// The raw type from the vocab package
	raw *vocab.Video
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Video) Raw() (n *vocab.Video) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Video) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Video) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Video) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Video) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Video) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Video) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Video) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Video) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Video) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Video) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Video) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Video) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Video) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Video) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Video) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Video) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Video) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Video) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Video) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Video) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Video) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Video) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Video) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Video) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Video) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Video) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Video) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Video) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Video) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Video) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Video) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Video) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Video) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Video) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Video) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Video) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Video) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Video) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Video) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Video) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Video) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Video) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Video) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Video) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Video) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Video) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Video) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Video) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Video) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Video) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Video) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Video) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Video) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Video) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Video) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Video) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Video) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Video) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Video) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Video) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Video) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Video) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Video) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Video) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Video) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Video) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Video) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Video) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Video) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Video) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Video) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Video) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Video) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Video) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Video) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Video) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Video) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Video) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Video) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Video) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Video) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Video) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Video) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Video) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Video) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Video) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Video) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Video) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Video) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Video) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Video) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Video) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Video) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Video) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Video) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Video) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Video) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Video) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Video) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Video) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Video) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a short written work typically less than a single paragraph in length. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Note struct {
	// The raw type from the vocab package
	raw *vocab.Note
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Note) Raw() (n *vocab.Note) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Note) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Note) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Note) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Note) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Note) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Note) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Note) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Note) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Note) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Note) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Note) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Note) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Note) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Note) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Note) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Note) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Note) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Note) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Note) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Note) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Note) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Note) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Note) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Note) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Note) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Note) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Note) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Note) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Note) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Note) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Note) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Note) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Note) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Note) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Note) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Note) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Note) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Note) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Note) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Note) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Note) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Note) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Note) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Note) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Note) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Note) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Note) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Note) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Note) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Note) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Note) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Note) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Note) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Note) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Note) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Note) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Note) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Note) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Note) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Note) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Note) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Note) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Note) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Note) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Note) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Note) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Note) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Note) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Note) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Note) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Note) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Note) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Note) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Note) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Note) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Note) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Note) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Note) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Note) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Note) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Note) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Note) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Note) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Note) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Note) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Note) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Note) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Note) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Note) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Note) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Note) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Note) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Note) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Note) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Note) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Note) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Note) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Note) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Note) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Note) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Note) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a Web Page. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Page struct {
	// The raw type from the vocab package
	raw *vocab.Page
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Page) Raw() (n *vocab.Page) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Page) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Page) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Page) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Page) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Page) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Page) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Page) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Page) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Page) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Page) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Page) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Page) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Page) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Page) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Page) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Page) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Page) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Page) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Page) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Page) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Page) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Page) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Page) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Page) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Page) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Page) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Page) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Page) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Page) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Page) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Page) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Page) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Page) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Page) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Page) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Page) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Page) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Page) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Page) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Page) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Page) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Page) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Page) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Page) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Page) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Page) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Page) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Page) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Page) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Page) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Page) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Page) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Page) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Page) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Page) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Page) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Page) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Page) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Page) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Page) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Page) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Page) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Page) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Page) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Page) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Page) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Page) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Page) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Page) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Page) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Page) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Page) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Page) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Page) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Page) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Page) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Page) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Page) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Page) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Page) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Page) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Page) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Page) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Page) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Page) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Page) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Page) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Page) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Page) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Page) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Page) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Page) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Page) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Page) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Page) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Page) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Page) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Page) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Page) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Page) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Page) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents any kind of event. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Event struct {
	// The raw type from the vocab package
	raw *vocab.Event
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Event) Raw() (n *vocab.Event) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Event) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Event) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Event) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Event) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Event) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Event) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Event) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Event) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Event) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Event) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Event) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Event) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Event) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Event) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Event) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Event) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Event) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Event) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Event) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Event) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Event) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Event) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Event) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Event) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Event) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Event) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Event) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Event) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Event) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Event) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Event) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Event) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Event) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Event) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Event) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Event) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Event) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Event) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Event) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Event) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Event) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Event) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Event) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Event) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Event) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Event) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Event) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Event) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Event) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Event) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Event) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Event) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Event) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Event) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Event) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Event) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Event) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Event) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Event) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Event) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Event) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Event) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Event) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Event) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Event) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Event) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Event) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Event) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Event) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Event) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Event) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Event) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Event) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Event) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Event) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Event) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Event) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Event) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Event) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Event) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Event) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Event) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Event) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Event) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Event) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Event) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Event) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Event) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Event) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Event) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Event) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Event) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Event) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Event) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Event) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Event) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Event) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Event) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Event) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Event) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Event) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// Represents a logical or physical location. See 5.3 Representing Places for additional information. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Place struct {
	// The raw type from the vocab package
	raw *vocab.Place
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Place) Raw() (n *vocab.Place) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Place) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// GetAccuracy attempts to get this 'accuracy' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetAccuracy() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAccuracy() {
		k = t.raw.GetAccuracy()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAccuracyIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAccuracy returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasAccuracy() (p Presence) {
	p = NoPresence
	if t.raw.IsAccuracy() {
		p = ConvenientPresence
	} else if t.raw.IsAccuracyIRI() {
		p = RawPresence
	}
	return

}

// SetAccuracy sets the value for property 'accuracy'.
func (t *Place) SetAccuracy(k float64) {
	t.raw.SetAccuracy(k)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Place) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// GetLatitude attempts to get this 'latitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetLatitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsLatitude() {
		k = t.raw.GetLatitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLatitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasLatitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasLatitude() (p Presence) {
	p = NoPresence
	if t.raw.IsLatitude() {
		p = ConvenientPresence
	} else if t.raw.IsLatitudeIRI() {
		p = RawPresence
	}
	return

}

// SetLatitude sets the value for property 'latitude'.
func (t *Place) SetLatitude(k float64) {
	t.raw.SetLatitude(k)

}

// GetLongitude attempts to get this 'longitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetLongitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsLongitude() {
		k = t.raw.GetLongitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsLongitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasLongitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasLongitude() (p Presence) {
	p = NoPresence
	if t.raw.IsLongitude() {
		p = ConvenientPresence
	} else if t.raw.IsLongitudeIRI() {
		p = RawPresence
	}
	return

}

// SetLongitude sets the value for property 'longitude'.
func (t *Place) SetLongitude(k float64) {
	t.raw.SetLongitude(k)

}

// GetRadius attempts to get this 'radius' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetRadius() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsRadius() {
		k = t.raw.GetRadius()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsRadiusIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasRadius returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasRadius() (p Presence) {
	p = NoPresence
	if t.raw.IsRadius() {
		p = ConvenientPresence
	} else if t.raw.IsRadiusIRI() {
		p = RawPresence
	}
	return

}

// SetRadius sets the value for property 'radius'.
func (t *Place) SetRadius(k float64) {
	t.raw.SetRadius(k)

}

// GetUnits attempts to get this 'units' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetUnits() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsUnitsUnitsValue() {
		k = t.raw.GetUnitsUnitsValue()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUnitsAnyURI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUnits returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasUnits() (p Presence) {
	p = NoPresence
	if t.raw.IsUnitsUnitsValue() {
		p = ConvenientPresence
	} else if t.raw.IsUnitsAnyURI() {
		p = RawPresence
	}
	return

}

// SetUnits sets the value for property 'units'.
func (t *Place) SetUnits(k string) {
	t.raw.SetUnitsUnitsValue(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Place) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Place) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Place) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Place) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Place) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Place) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Place) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Place) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Place) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Place) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Place) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Place) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Place) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Place) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Place) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Place) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Place) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Place) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Place) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Place) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Place) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Place) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Place) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Place) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Place) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Place) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Place) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Place) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Place) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Place) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Place) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Place) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Place) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Place) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Place) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Place) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Place) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Place) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Place) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Place) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Place) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Place) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Place) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Place) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Place) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Place) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Place) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Place) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Place) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Place) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Place) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Place) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Place) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Place) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Place) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Place) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Place) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Place) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Place) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Place) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Place) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Place) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Place) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Place) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Place) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Place) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Place) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Place) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Place) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Place) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Place) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Place) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Place) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Place) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Place) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Place) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Place) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Place) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Place) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Place) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Place) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Place) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Place) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Place) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Place) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Place) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Place) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Place) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Place) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Place) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Place) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Place) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Place) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Place) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Place) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Place) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Place) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Place) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Place) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A Profile is a content object that describes another Object, typically used to describe Actor Type objects. The describes property is used to reference the object being described by the profile. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Profile struct {
	// The raw type from the vocab package
	raw *vocab.Profile
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Profile) Raw() (n *vocab.Profile) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Profile) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// ResolveDescribes passes the actual concrete type to the resolver for handing property describes. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveDescribes(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsDescribes() {
		handled, err = r.dispatch(t.raw.GetDescribes())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsDescribesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasDescribes returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasDescribes() (p Presence) {
	p = NoPresence
	if t.raw.IsDescribes() {
		p = ConvenientPresence
	} else if t.raw.IsDescribesIRI() {
		p = RawPresence
	}
	return

}

// SetDescribes sets this value to be a 'Object' type.
func (t *Profile) SetDescribes(i vocab.ObjectType) {
	t.raw.SetDescribes(i)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Profile) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Profile) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Profile) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Profile) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Profile) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Profile) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Profile) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Profile) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Profile) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Profile) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Profile) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Profile) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Profile) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Profile) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Profile) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Profile) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Profile) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Profile) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Profile) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Profile) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Profile) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Profile) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Profile) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Profile) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Profile) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Profile) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Profile) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Profile) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Profile) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Profile) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Profile) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Profile) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Profile) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Profile) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Profile) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Profile) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Profile) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Profile) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Profile) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Profile) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Profile) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Profile) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Profile) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Profile) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Profile) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Profile) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Profile) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Profile) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Profile) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Profile) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Profile) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Profile) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Profile) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Profile) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Profile) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Profile) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Profile) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Profile) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Profile) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Profile) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Profile) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Profile) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Profile) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Profile) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Profile) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Profile) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Profile) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Profile) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Profile) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Profile) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Profile) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Profile) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Profile) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Profile) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Profile) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Profile) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Profile) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Profile) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Profile) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Profile) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Profile) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Profile) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Profile) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Profile) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Profile) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Profile) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Profile) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Profile) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Profile) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Profile) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Profile) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Profile) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Profile) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Profile) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Profile) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Profile) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Profile) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Profile) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Profile) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Profile) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A Tombstone represents a content object that has been deleted. It can be used in Collections to signify that there used to be an object at this position, but it has been deleted. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Tombstone struct {
	// The raw type from the vocab package
	raw *vocab.Tombstone
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Tombstone) Raw() (n *vocab.Tombstone) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Tombstone) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenFormerType returns the number of values this property contains. Each index be used with HasFormerType to determine if GetFormerType is safe to call or if raw handling would be needed.%!(EXTRA string=formerType)
func (t *Tombstone) LenFormerType() (idx int) {
	return t.raw.FormerTypeLen()

}

// GetFormerType attempts to get this 'formerType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetFormerType(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsFormerTypeString(idx) {
		k = t.raw.GetFormerTypeString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsFormerTypeObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsFormerTypeIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddFormerType appends the value for property 'formerType'.
func (t *Tombstone) AddFormerType(k string) {
	t.raw.AddFormerTypeString(k)

}

// RemoveFormerType deletes the value from the specified index for property 'formerType'.
func (t *Tombstone) RemoveFormerType(idx int) {
	t.raw.RemoveFormerTypeString(idx)

}

// HasFormerType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasFormerType(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsFormerTypeString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsFormerTypeObject(idx) {
		p = RawPresence
	} else if t.raw.IsFormerTypeIRI(idx) {
		p = RawPresence
	}
	return

}

// GetDeleted attempts to get this 'deleted' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetDeleted() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsDeleted() {
		k = t.raw.GetDeleted()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDeletedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDeleted returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasDeleted() (p Presence) {
	p = NoPresence
	if t.raw.IsDeleted() {
		p = ConvenientPresence
	} else if t.raw.IsDeletedIRI() {
		p = RawPresence
	}
	return

}

// SetDeleted sets the value for property 'deleted'.
func (t *Tombstone) SetDeleted(k time.Time) {
	t.raw.SetDeleted(k)

}

// GetAltitude attempts to get this 'altitude' property as a float64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetAltitude() (r Resolution, k float64) {
	r = Unresolved
	handled := false
	if t.raw.IsAltitude() {
		k = t.raw.GetAltitude()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAltitudeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasAltitude returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasAltitude() (p Presence) {
	p = NoPresence
	if t.raw.IsAltitude() {
		p = ConvenientPresence
	} else if t.raw.IsAltitudeIRI() {
		p = RawPresence
	}
	return

}

// SetAltitude sets the value for property 'altitude'.
func (t *Tombstone) SetAltitude(k float64) {
	t.raw.SetAltitude(k)

}

// LenAttachment returns the number of values this property contains. Each index be used with HasAttachment to determine if ResolveAttachment is safe to call or if raw handling would be needed.%!(EXTRA string=attachment)
func (t *Tombstone) LenAttachment() (idx int) {
	return t.raw.AttachmentLen()

}

// ResolveAttachment passes the actual concrete type to the resolver for handing property attachment. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveAttachment(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsAttachmentObject(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentLink(idx) {
		handled, err = r.dispatch(t.raw.GetAttachmentLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsAttachmentIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasAttachment returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasAttachment(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttachmentObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttachmentIRI(idx) {
		p = RawPresence
	}
	return

}

// AddAttachment adds an 'Object' typed value.
func (t *Tombstone) AddAttachment(i vocab.ObjectType) {
	t.raw.AddAttachmentObject(i)

}

// SetAttachmentLink adds a 'Link' typed value.
func (t *Tombstone) SetAttachmentLink(i vocab.LinkType) {
	t.raw.AddAttachmentLink(i)

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Tombstone) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Tombstone) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Tombstone) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenAudience returns the number of values this property contains. Each index be used with HasAudience to determine if GetAudience is safe to call or if raw handling would be needed.%!(EXTRA string=audience)
func (t *Tombstone) LenAudience() (idx int) {
	return t.raw.AudienceLen()

}

// GetAudience attempts to get this 'audience' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetAudience(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAudienceIRI(idx) {
		k = t.raw.GetAudienceIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAudienceObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAudienceLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAudience appends the value for property 'audience'.
func (t *Tombstone) AddAudience(k url.URL) {
	t.raw.AddAudienceIRI(k)

}

// RemoveAudience deletes the value from the specified index for property 'audience'.
func (t *Tombstone) RemoveAudience(idx int) {
	t.raw.RemoveAudienceIRI(idx)

}

// HasAudience returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasAudience(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAudienceIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAudienceLink(idx) {
		p = RawPresence
	} else if t.raw.IsAudienceIRI(idx) {
		p = RawPresence
	}
	return

}

// LenContent returns the number of values this property contains. Each index be used with HasContent to determine if GetContent is safe to call or if raw handling would be needed.%!(EXTRA string=content)
func (t *Tombstone) LenContent() (idx int) {
	return t.raw.ContentLen()

}

// GetContent attempts to get this 'content' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetContent(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsContentString(idx) {
		k = t.raw.GetContentString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsContentLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsContentIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddContent appends the value for property 'content'.
func (t *Tombstone) AddContent(k string) {
	t.raw.AddContentString(k)

}

// RemoveContent deletes the value from the specified index for property 'content'.
func (t *Tombstone) RemoveContent(idx int) {
	t.raw.RemoveContentString(idx)

}

// HasContent returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasContent(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContentString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContentLangString(idx) {
		p = RawPresence
	} else if t.raw.IsContentIRI(idx) {
		p = RawPresence
	}
	return

}

// ContentLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Tombstone) ContentLanguages() (l []string) {
	return t.raw.ContentMapLanguages()

}

// GetContentMap retrieves the value of 'content' for the specified language, or an empty string if it does not exist
func (t *Tombstone) GetContentForLanguage(l string) (v string) {
	return t.raw.GetContentMap(l)

}

// SetContentForLanguage sets the value of 'content' for the specified language
func (t *Tombstone) SetContentForLanguage(l string, v string) {
	t.raw.SetContentMap(l, v)

}

// LenContext returns the number of values this property contains. Each index be used with HasContext to determine if ResolveContext is safe to call or if raw handling would be needed.%!(EXTRA string=context)
func (t *Tombstone) LenContext() (idx int) {
	return t.raw.ContextLen()

}

// ResolveContext passes the actual concrete type to the resolver for handing property context. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveContext(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsContextObject(idx) {
		handled, err = r.dispatch(t.raw.GetContextObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextLink(idx) {
		handled, err = r.dispatch(t.raw.GetContextLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsContextIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasContext returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasContext(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsContextObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsContextIRI(idx) {
		p = RawPresence
	}
	return

}

// AddContext adds an 'Object' typed value.
func (t *Tombstone) AddContext(i vocab.ObjectType) {
	t.raw.AddContextObject(i)

}

// SetContextLink adds a 'Link' typed value.
func (t *Tombstone) SetContextLink(i vocab.LinkType) {
	t.raw.AddContextLink(i)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Tombstone) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Tombstone) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Tombstone) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Tombstone) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Tombstone) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Tombstone) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// GetEndTime attempts to get this 'endTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetEndTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsEndTime() {
		k = t.raw.GetEndTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsEndTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasEndTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasEndTime() (p Presence) {
	p = NoPresence
	if t.raw.IsEndTime() {
		p = ConvenientPresence
	} else if t.raw.IsEndTimeIRI() {
		p = RawPresence
	}
	return

}

// SetEndTime sets the value for property 'endTime'.
func (t *Tombstone) SetEndTime(k time.Time) {
	t.raw.SetEndTime(k)

}

// LenGenerator returns the number of values this property contains. Each index be used with HasGenerator to determine if ResolveGenerator is safe to call or if raw handling would be needed.%!(EXTRA string=generator)
func (t *Tombstone) LenGenerator() (idx int) {
	return t.raw.GeneratorLen()

}

// ResolveGenerator passes the actual concrete type to the resolver for handing property generator. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveGenerator(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsGeneratorObject(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorLink(idx) {
		handled, err = r.dispatch(t.raw.GetGeneratorLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsGeneratorIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasGenerator returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasGenerator(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsGeneratorObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsGeneratorIRI(idx) {
		p = RawPresence
	}
	return

}

// AddGenerator adds an 'Object' typed value.
func (t *Tombstone) AddGenerator(i vocab.ObjectType) {
	t.raw.AddGeneratorObject(i)

}

// SetGeneratorLink adds a 'Link' typed value.
func (t *Tombstone) SetGeneratorLink(i vocab.LinkType) {
	t.raw.AddGeneratorLink(i)

}

// LenIcon returns the number of values this property contains. Each index be used with HasIcon to determine if ResolveIcon is safe to call or if raw handling would be needed.%!(EXTRA string=icon)
func (t *Tombstone) LenIcon() (idx int) {
	return t.raw.IconLen()

}

// ResolveIcon passes the actual concrete type to the resolver for handing property icon. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveIcon(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsIconImage(idx) {
		handled, err = r.dispatch(t.raw.GetIconImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsIconLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsIconIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddIcon appends the value for property 'icon'.
func (t *Tombstone) AddIcon(i vocab.ImageType) {
	t.raw.AddIconImage(i)

}

// RemoveIcon deletes the value from the specified index for property 'icon'.
func (t *Tombstone) RemoveIcon(idx int) {
	t.raw.RemoveIconImage(idx)

}

// HasIcon returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasIcon(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsIconImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsIconLink(idx) {
		p = RawPresence
	} else if t.raw.IsIconIRI(idx) {
		p = RawPresence
	}
	return

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Tombstone) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenImage returns the number of values this property contains. Each index be used with HasImage to determine if ResolveImage is safe to call or if raw handling would be needed.%!(EXTRA string=image)
func (t *Tombstone) LenImage() (idx int) {
	return t.raw.ImageLen()

}

// ResolveImage passes the actual concrete type to the resolver for handing property image. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveImage(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsImageImage(idx) {
		handled, err = r.dispatch(t.raw.GetImageImage(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsImageLink(idx) {
		s = RawResolutionNeeded
	} else if t.raw.IsImageIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// AddImage appends the value for property 'image'.
func (t *Tombstone) AddImage(i vocab.ImageType) {
	t.raw.AddImageImage(i)

}

// RemoveImage deletes the value from the specified index for property 'image'.
func (t *Tombstone) RemoveImage(idx int) {
	t.raw.RemoveImageImage(idx)

}

// HasImage returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasImage(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsImageImage(idx) {
		p = ConvenientPresence
	} else if t.raw.IsImageLink(idx) {
		p = RawPresence
	} else if t.raw.IsImageIRI(idx) {
		p = RawPresence
	}
	return

}

// LenInReplyTo returns the number of values this property contains. Each index be used with HasInReplyTo to determine if GetInReplyTo is safe to call or if raw handling would be needed.%!(EXTRA string=inReplyTo)
func (t *Tombstone) LenInReplyTo() (idx int) {
	return t.raw.InReplyToLen()

}

// GetInReplyTo attempts to get this 'inReplyTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetInReplyTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsInReplyToIRI(idx) {
		k = t.raw.GetInReplyToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsInReplyToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsInReplyToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddInReplyTo appends the value for property 'inReplyTo'.
func (t *Tombstone) AddInReplyTo(k url.URL) {
	t.raw.AddInReplyToIRI(k)

}

// RemoveInReplyTo deletes the value from the specified index for property 'inReplyTo'.
func (t *Tombstone) RemoveInReplyTo(idx int) {
	t.raw.RemoveInReplyToIRI(idx)

}

// HasInReplyTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasInReplyTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsInReplyToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsInReplyToLink(idx) {
		p = RawPresence
	} else if t.raw.IsInReplyToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenLocation returns the number of values this property contains. Each index be used with HasLocation to determine if ResolveLocation is safe to call or if raw handling would be needed.%!(EXTRA string=location)
func (t *Tombstone) LenLocation() (idx int) {
	return t.raw.LocationLen()

}

// ResolveLocation passes the actual concrete type to the resolver for handing property location. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveLocation(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsLocationObject(idx) {
		handled, err = r.dispatch(t.raw.GetLocationObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationLink(idx) {
		handled, err = r.dispatch(t.raw.GetLocationLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsLocationIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasLocation returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasLocation(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsLocationObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsLocationIRI(idx) {
		p = RawPresence
	}
	return

}

// AddLocation adds an 'Object' typed value.
func (t *Tombstone) AddLocation(i vocab.ObjectType) {
	t.raw.AddLocationObject(i)

}

// SetLocationLink adds a 'Link' typed value.
func (t *Tombstone) SetLocationLink(i vocab.LinkType) {
	t.raw.AddLocationLink(i)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Tombstone) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Tombstone) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Tombstone) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}

// GetPublished attempts to get this 'published' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetPublished() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsPublished() {
		k = t.raw.GetPublished()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPublishedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPublished returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasPublished() (p Presence) {
	p = NoPresence
	if t.raw.IsPublished() {
		p = ConvenientPresence
	} else if t.raw.IsPublishedIRI() {
		p = RawPresence
	}
	return

}

// SetPublished sets the value for property 'published'.
func (t *Tombstone) SetPublished(k time.Time) {
	t.raw.SetPublished(k)

}

// ResolveReplies passes the actual concrete type to the resolver for handing property replies. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveReplies(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsReplies() {
		handled, err = r.dispatch(t.raw.GetReplies())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsRepliesIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasReplies returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasReplies() (p Presence) {
	p = NoPresence
	if t.raw.IsReplies() {
		p = ConvenientPresence
	} else if t.raw.IsRepliesIRI() {
		p = RawPresence
	}
	return

}

// SetReplies sets this value to be a 'Collection' type.
func (t *Tombstone) SetReplies(i vocab.CollectionType) {
	t.raw.SetReplies(i)

}

// GetStartTime attempts to get this 'startTime' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetStartTime() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsStartTime() {
		k = t.raw.GetStartTime()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsStartTimeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasStartTime returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasStartTime() (p Presence) {
	p = NoPresence
	if t.raw.IsStartTime() {
		p = ConvenientPresence
	} else if t.raw.IsStartTimeIRI() {
		p = RawPresence
	}
	return

}

// SetStartTime sets the value for property 'startTime'.
func (t *Tombstone) SetStartTime(k time.Time) {
	t.raw.SetStartTime(k)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Tombstone) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Tombstone) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Tombstone) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Tombstone) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Tombstone) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Tombstone) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// LenTag returns the number of values this property contains. Each index be used with HasTag to determine if ResolveTag is safe to call or if raw handling would be needed.%!(EXTRA string=tag)
func (t *Tombstone) LenTag() (idx int) {
	return t.raw.TagLen()

}

// ResolveTag passes the actual concrete type to the resolver for handing property tag. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveTag(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsTagObject(idx) {
		handled, err = r.dispatch(t.raw.GetTagObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagLink(idx) {
		handled, err = r.dispatch(t.raw.GetTagLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsTagIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasTag returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasTag(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsTagObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsTagIRI(idx) {
		p = RawPresence
	}
	return

}

// AddTag adds an 'Object' typed value.
func (t *Tombstone) AddTag(i vocab.ObjectType) {
	t.raw.AddTagObject(i)

}

// SetTagLink adds a 'Link' typed value.
func (t *Tombstone) SetTagLink(i vocab.LinkType) {
	t.raw.AddTagLink(i)

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Tombstone) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Tombstone) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Tombstone) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetUpdated attempts to get this 'updated' property as a time.Time. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetUpdated() (r Resolution, k time.Time) {
	r = Unresolved
	handled := false
	if t.raw.IsUpdated() {
		k = t.raw.GetUpdated()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUpdatedIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasUpdated returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasUpdated() (p Presence) {
	p = NoPresence
	if t.raw.IsUpdated() {
		p = ConvenientPresence
	} else if t.raw.IsUpdatedIRI() {
		p = RawPresence
	}
	return

}

// SetUpdated sets the value for property 'updated'.
func (t *Tombstone) SetUpdated(k time.Time) {
	t.raw.SetUpdated(k)

}

// LenUrl returns the number of values this property contains. Each index be used with HasUrl to determine if GetUrl is safe to call or if raw handling would be needed.%!(EXTRA string=url)
func (t *Tombstone) LenUrl() (idx int) {
	return t.raw.UrlLen()

}

// GetUrl attempts to get this 'url' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetUrl(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsUrlAnyURI(idx) {
		k = t.raw.GetUrlAnyURI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsUrlLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddUrl appends the value for property 'url'.
func (t *Tombstone) AddUrl(k url.URL) {
	t.raw.AddUrlAnyURI(k)

}

// RemoveUrl deletes the value from the specified index for property 'url'.
func (t *Tombstone) RemoveUrl(idx int) {
	t.raw.RemoveUrlAnyURI(idx)

}

// HasUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasUrl(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsUrlAnyURI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsUrlLink(idx) {
		p = RawPresence
	}
	return

}

// LenTo returns the number of values this property contains. Each index be used with HasTo to determine if GetTo is safe to call or if raw handling would be needed.%!(EXTRA string=to)
func (t *Tombstone) LenTo() (idx int) {
	return t.raw.ToLen()

}

// GetTo attempts to get this 'to' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsToIRI(idx) {
		k = t.raw.GetToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddTo appends the value for property 'to'.
func (t *Tombstone) AddTo(k url.URL) {
	t.raw.AddToIRI(k)

}

// RemoveTo deletes the value from the specified index for property 'to'.
func (t *Tombstone) RemoveTo(idx int) {
	t.raw.RemoveToIRI(idx)

}

// HasTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsToLink(idx) {
		p = RawPresence
	} else if t.raw.IsToIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBto returns the number of values this property contains. Each index be used with HasBto to determine if GetBto is safe to call or if raw handling would be needed.%!(EXTRA string=bto)
func (t *Tombstone) LenBto() (idx int) {
	return t.raw.BtoLen()

}

// GetBto attempts to get this 'bto' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetBto(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBtoIRI(idx) {
		k = t.raw.GetBtoIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBtoObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBtoLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBto appends the value for property 'bto'.
func (t *Tombstone) AddBto(k url.URL) {
	t.raw.AddBtoIRI(k)

}

// RemoveBto deletes the value from the specified index for property 'bto'.
func (t *Tombstone) RemoveBto(idx int) {
	t.raw.RemoveBtoIRI(idx)

}

// HasBto returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasBto(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBtoIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBtoLink(idx) {
		p = RawPresence
	} else if t.raw.IsBtoIRI(idx) {
		p = RawPresence
	}
	return

}

// LenCc returns the number of values this property contains. Each index be used with HasCc to determine if GetCc is safe to call or if raw handling would be needed.%!(EXTRA string=cc)
func (t *Tombstone) LenCc() (idx int) {
	return t.raw.CcLen()

}

// GetCc attempts to get this 'cc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetCc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsCcIRI(idx) {
		k = t.raw.GetCcIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsCcObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsCcLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddCc appends the value for property 'cc'.
func (t *Tombstone) AddCc(k url.URL) {
	t.raw.AddCcIRI(k)

}

// RemoveCc deletes the value from the specified index for property 'cc'.
func (t *Tombstone) RemoveCc(idx int) {
	t.raw.RemoveCcIRI(idx)

}

// HasCc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasCc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsCcIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsCcLink(idx) {
		p = RawPresence
	} else if t.raw.IsCcIRI(idx) {
		p = RawPresence
	}
	return

}

// LenBcc returns the number of values this property contains. Each index be used with HasBcc to determine if GetBcc is safe to call or if raw handling would be needed.%!(EXTRA string=bcc)
func (t *Tombstone) LenBcc() (idx int) {
	return t.raw.BccLen()

}

// GetBcc attempts to get this 'bcc' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetBcc(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsBccIRI(idx) {
		k = t.raw.GetBccIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsBccObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsBccLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddBcc appends the value for property 'bcc'.
func (t *Tombstone) AddBcc(k url.URL) {
	t.raw.AddBccIRI(k)

}

// RemoveBcc deletes the value from the specified index for property 'bcc'.
func (t *Tombstone) RemoveBcc(idx int) {
	t.raw.RemoveBccIRI(idx)

}

// HasBcc returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasBcc(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsBccIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsBccLink(idx) {
		p = RawPresence
	} else if t.raw.IsBccIRI(idx) {
		p = RawPresence
	}
	return

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Tombstone) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// GetDuration attempts to get this 'duration' property as a time.Duration. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetDuration() (r Resolution, k time.Duration) {
	r = Unresolved
	handled := false
	if t.raw.IsDuration() {
		k = t.raw.GetDuration()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsDurationIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasDuration returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasDuration() (p Presence) {
	p = NoPresence
	if t.raw.IsDuration() {
		p = ConvenientPresence
	} else if t.raw.IsDurationIRI() {
		p = RawPresence
	}
	return

}

// SetDuration sets the value for property 'duration'.
func (t *Tombstone) SetDuration(k time.Duration) {
	t.raw.SetDuration(k)

}

// ResolveSource passes the actual concrete type to the resolver for handing property source. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveSource(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsSource() {
		handled, err = r.dispatch(t.raw.GetSource())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsSourceIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasSource returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasSource() (p Presence) {
	p = NoPresence
	if t.raw.IsSource() {
		p = ConvenientPresence
	} else if t.raw.IsSourceIRI() {
		p = RawPresence
	}
	return

}

// SetSource sets this value to be a 'Object' type.
func (t *Tombstone) SetSource(i vocab.ObjectType) {
	t.raw.SetSource(i)

}

// GetInbox attempts to get this 'inbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasInbox() {
		k = t.raw.GetInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasInbox() {
		p = ConvenientPresence
	}
	return

}

// SetInbox sets the value for property 'inbox'.
func (t *Tombstone) SetInbox(k url.URL) {
	t.raw.SetInbox(k)

}

// GetOutbox attempts to get this 'outbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetOutbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOutbox() {
		k = t.raw.GetOutbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOutbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasOutbox() (p Presence) {
	p = NoPresence
	if t.raw.HasOutbox() {
		p = ConvenientPresence
	}
	return

}

// SetOutbox sets the value for property 'outbox'.
func (t *Tombstone) SetOutbox(k url.URL) {
	t.raw.SetOutbox(k)

}

// GetFollowing attempts to get this 'following' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetFollowing() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowing() {
		k = t.raw.GetFollowing()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowing returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasFollowing() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowing() {
		p = ConvenientPresence
	}
	return

}

// SetFollowing sets the value for property 'following'.
func (t *Tombstone) SetFollowing(k url.URL) {
	t.raw.SetFollowing(k)

}

// GetFollowers attempts to get this 'followers' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetFollowers() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasFollowers() {
		k = t.raw.GetFollowers()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasFollowers returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasFollowers() (p Presence) {
	p = NoPresence
	if t.raw.HasFollowers() {
		p = ConvenientPresence
	}
	return

}

// SetFollowers sets the value for property 'followers'.
func (t *Tombstone) SetFollowers(k url.URL) {
	t.raw.SetFollowers(k)

}

// GetLiked attempts to get this 'liked' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetLiked() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasLiked() {
		k = t.raw.GetLiked()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasLiked returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasLiked() (p Presence) {
	p = NoPresence
	if t.raw.HasLiked() {
		p = ConvenientPresence
	}
	return

}

// SetLiked sets the value for property 'liked'.
func (t *Tombstone) SetLiked(k url.URL) {
	t.raw.SetLiked(k)

}

// LenStreams returns the number of values this property contains. Each index be used with HasStreams to determine if GetStreams is safe to call or if raw handling would be needed.%!(EXTRA string=streams)
func (t *Tombstone) LenStreams() (idx int) {
	return t.raw.StreamsLen()

}

// GetStreams attempts to get this 'streams' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetStreams(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if /*t.raw.HasStreams(idx)*/ true {
		k = t.raw.GetStreams(idx)
		if handled {
			r = Resolved
		}
	}
	return

}

// AddStreams appends the value for property 'streams'.
func (t *Tombstone) AddStreams(k url.URL) {
	t.raw.AddStreams(k)

}

// RemoveStreams deletes the value from the specified index for property 'streams'.
func (t *Tombstone) RemoveStreams(idx int) {
	t.raw.RemoveStreams(idx)

}

// GetPreferredUsername attempts to get this 'preferredUsername' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetPreferredUsername() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsPreferredUsername() {
		k = t.raw.GetPreferredUsername()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsPreferredUsernameIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasPreferredUsername returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasPreferredUsername() (p Presence) {
	p = NoPresence
	if t.raw.IsPreferredUsername() {
		p = ConvenientPresence
	} else if t.raw.IsPreferredUsernameIRI() {
		p = RawPresence
	}
	return

}

// SetPreferredUsername sets the value for property 'preferredUsername'.
func (t *Tombstone) SetPreferredUsername(k string) {
	t.raw.SetPreferredUsername(k)

}

// PreferredUsernameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Tombstone) PreferredUsernameLanguages() (l []string) {
	return t.raw.PreferredUsernameMapLanguages()

}

// GetPreferredUsernameMap retrieves the value of 'preferredUsername' for the specified language, or an empty string if it does not exist
func (t *Tombstone) GetPreferredUsernameForLanguage(l string) (v string) {
	return t.raw.GetPreferredUsernameMap(l)

}

// SetPreferredUsernameForLanguage sets the value of 'preferredUsername' for the specified language
func (t *Tombstone) SetPreferredUsernameForLanguage(l string, v string) {
	t.raw.SetPreferredUsernameMap(l, v)

}

// ResolveEndpoints passes the actual concrete type to the resolver for handing property endpoints. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) ResolveEndpoints(r *Resolver) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsEndpoints() {
		handled, err = r.dispatch(t.raw.GetEndpoints())
		if handled {
			s = Resolved
		}
	} else if t.raw.IsEndpointsIRI() {
		s = RawResolutionNeeded
	}
	return

}

// HasEndpoints returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasEndpoints() (p Presence) {
	p = NoPresence
	if t.raw.IsEndpoints() {
		p = ConvenientPresence
	} else if t.raw.IsEndpointsIRI() {
		p = RawPresence
	}
	return

}

// SetEndpoints sets this value to be a 'Object' type.
func (t *Tombstone) SetEndpoints(i vocab.ObjectType) {
	t.raw.SetEndpoints(i)

}

// GetProxyUrl attempts to get this 'proxyUrl' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetProxyUrl() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProxyUrl() {
		k = t.raw.GetProxyUrl()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProxyUrl returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasProxyUrl() (p Presence) {
	p = NoPresence
	if t.raw.HasProxyUrl() {
		p = ConvenientPresence
	}
	return

}

// SetProxyUrl sets the value for property 'proxyUrl'.
func (t *Tombstone) SetProxyUrl(k url.URL) {
	t.raw.SetProxyUrl(k)

}

// GetOauthAuthorizationEndpoint attempts to get this 'oauthAuthorizationEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetOauthAuthorizationEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthAuthorizationEndpoint() {
		k = t.raw.GetOauthAuthorizationEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthAuthorizationEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasOauthAuthorizationEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthAuthorizationEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthAuthorizationEndpoint sets the value for property 'oauthAuthorizationEndpoint'.
func (t *Tombstone) SetOauthAuthorizationEndpoint(k url.URL) {
	t.raw.SetOauthAuthorizationEndpoint(k)

}

// GetOauthTokenEndpoint attempts to get this 'oauthTokenEndpoint' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetOauthTokenEndpoint() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasOauthTokenEndpoint() {
		k = t.raw.GetOauthTokenEndpoint()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasOauthTokenEndpoint returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasOauthTokenEndpoint() (p Presence) {
	p = NoPresence
	if t.raw.HasOauthTokenEndpoint() {
		p = ConvenientPresence
	}
	return

}

// SetOauthTokenEndpoint sets the value for property 'oauthTokenEndpoint'.
func (t *Tombstone) SetOauthTokenEndpoint(k url.URL) {
	t.raw.SetOauthTokenEndpoint(k)

}

// GetProvideClientKey attempts to get this 'provideClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetProvideClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasProvideClientKey() {
		k = t.raw.GetProvideClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasProvideClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasProvideClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasProvideClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetProvideClientKey sets the value for property 'provideClientKey'.
func (t *Tombstone) SetProvideClientKey(k url.URL) {
	t.raw.SetProvideClientKey(k)

}

// GetSignClientKey attempts to get this 'signClientKey' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetSignClientKey() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSignClientKey() {
		k = t.raw.GetSignClientKey()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSignClientKey returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasSignClientKey() (p Presence) {
	p = NoPresence
	if t.raw.HasSignClientKey() {
		p = ConvenientPresence
	}
	return

}

// SetSignClientKey sets the value for property 'signClientKey'.
func (t *Tombstone) SetSignClientKey(k url.URL) {
	t.raw.SetSignClientKey(k)

}

// GetSharedInbox attempts to get this 'sharedInbox' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Tombstone) GetSharedInbox() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasSharedInbox() {
		k = t.raw.GetSharedInbox()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasSharedInbox returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Tombstone) HasSharedInbox() (p Presence) {
	p = NoPresence
	if t.raw.HasSharedInbox() {
		p = ConvenientPresence
	}
	return

}

// SetSharedInbox sets the value for property 'sharedInbox'.
func (t *Tombstone) SetSharedInbox(k url.URL) {
	t.raw.SetSharedInbox(k)

}

// A specialized Link that represents an @mention. This is a convenience wrapper of a type with the same name in the vocab package. Accessing it with the Raw function allows direct manipulaton of the object, and does not provide the same integrity guarantees as this package.
type Mention struct {
	// The raw type from the vocab package
	raw *vocab.Mention
}

// Raw returns the vocab type for manaual manipulation. Note that manipulating the underlying type to be in an inconsistent state may cause this convenience type's methods to later fail.
func (t *Mention) Raw() (n *vocab.Mention) {
	return t.raw

}

// Serialize turns this object into a map[string]interface{}.
func (t *Mention) Serialize() (m map[string]interface{}, err error) {
	return t.raw.Serialize()

}

// LenAttributedTo returns the number of values this property contains. Each index be used with HasAttributedTo to determine if GetAttributedTo is safe to call or if raw handling would be needed.%!(EXTRA string=attributedTo)
func (t *Mention) LenAttributedTo() (idx int) {
	return t.raw.AttributedToLen()

}

// GetAttributedTo attempts to get this 'attributedTo' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetAttributedTo(idx int) (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.IsAttributedToIRI(idx) {
		k = t.raw.GetAttributedToIRI(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsAttributedToObject(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsAttributedToLink(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddAttributedTo appends the value for property 'attributedTo'.
func (t *Mention) AddAttributedTo(k url.URL) {
	t.raw.AddAttributedToIRI(k)

}

// RemoveAttributedTo deletes the value from the specified index for property 'attributedTo'.
func (t *Mention) RemoveAttributedTo(idx int) {
	t.raw.RemoveAttributedToIRI(idx)

}

// HasAttributedTo returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasAttributedTo(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsAttributedToIRI(idx) {
		p = ConvenientPresence
	} else if t.raw.IsAttributedToLink(idx) {
		p = RawPresence
	} else if t.raw.IsAttributedToIRI(idx) {
		p = RawPresence
	}
	return

}

// GetHref attempts to get this 'href' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetHref() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasHref() {
		k = t.raw.GetHref()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasHref returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasHref() (p Presence) {
	p = NoPresence
	if t.raw.HasHref() {
		p = ConvenientPresence
	}
	return

}

// SetHref sets the value for property 'href'.
func (t *Mention) SetHref(k url.URL) {
	t.raw.SetHref(k)

}

// GetId attempts to get this 'id' property as a url.URL. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetId() (r Resolution, k url.URL) {
	r = Unresolved
	handled := false
	if t.raw.HasId() {
		k = t.raw.GetId()
		if handled {
			r = Resolved
		}
	}
	return

}

// HasId returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasId() (p Presence) {
	p = NoPresence
	if t.raw.HasId() {
		p = ConvenientPresence
	}
	return

}

// SetId sets the value for property 'id'.
func (t *Mention) SetId(k url.URL) {
	t.raw.SetId(k)

}

// LenRel returns the number of values this property contains. Each index be used with HasRel to determine if GetRel is safe to call or if raw handling would be needed.%!(EXTRA string=rel)
func (t *Mention) LenRel() (idx int) {
	return t.raw.RelLen()

}

// GetRel attempts to get this 'rel' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetRel(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsRel(idx) {
		k = t.raw.GetRel(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsRelIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddRel appends the value for property 'rel'.
func (t *Mention) AddRel(k string) {
	t.raw.AddRel(k)

}

// RemoveRel deletes the value from the specified index for property 'rel'.
func (t *Mention) RemoveRel(idx int) {
	t.raw.RemoveRel(idx)

}

// HasRel returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasRel(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsRel(idx) {
		p = ConvenientPresence
	} else if t.raw.IsRelIRI(idx) {
		p = RawPresence
	}
	return

}

// LenType returns the number of values this property contains. Each index be used with HasType to determine if GetType is safe to call or if raw handling would be needed.%!(EXTRA string=type)
func (t *Mention) LenType() (idx int) {
	return t.raw.TypeLen()

}

// GetType attempts to get this 'type' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetType(idx int) (r Resolution, s string) {
	r = Unresolved
	if tmp := t.raw.GetType(idx); tmp != nil {
		ok := false
		if s, ok = tmp.(string); ok {
			r = Resolved
		} else {
			r = RawResolutionNeeded
		}
	}
	return

}

// AddType appends the value for property 'type'.
func (t *Mention) AddType(i interface{}) {
	t.raw.AddType(i)

}

// RemoveType deletes the value from the specified index for property 'type'.
func (t *Mention) RemoveType(idx int) {
	t.raw.RemoveType(idx)

}

// GetMediaType attempts to get this 'mediaType' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetMediaType() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsMediaType() {
		k = t.raw.GetMediaType()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsMediaTypeIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasMediaType returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasMediaType() (p Presence) {
	p = NoPresence
	if t.raw.IsMediaType() {
		p = ConvenientPresence
	} else if t.raw.IsMediaTypeIRI() {
		p = RawPresence
	}
	return

}

// SetMediaType sets the value for property 'mediaType'.
func (t *Mention) SetMediaType(k string) {
	t.raw.SetMediaType(k)

}

// LenName returns the number of values this property contains. Each index be used with HasName to determine if GetName is safe to call or if raw handling would be needed.%!(EXTRA string=name)
func (t *Mention) LenName() (idx int) {
	return t.raw.NameLen()

}

// GetName attempts to get this 'name' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetName(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsNameString(idx) {
		k = t.raw.GetNameString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsNameLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsNameIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddName appends the value for property 'name'.
func (t *Mention) AddName(k string) {
	t.raw.AddNameString(k)

}

// RemoveName deletes the value from the specified index for property 'name'.
func (t *Mention) RemoveName(idx int) {
	t.raw.RemoveNameString(idx)

}

// HasName returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasName(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsNameString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsNameLangString(idx) {
		p = RawPresence
	} else if t.raw.IsNameIRI(idx) {
		p = RawPresence
	}
	return

}

// NameLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Mention) NameLanguages() (l []string) {
	return t.raw.NameMapLanguages()

}

// GetNameMap retrieves the value of 'name' for the specified language, or an empty string if it does not exist
func (t *Mention) GetNameForLanguage(l string) (v string) {
	return t.raw.GetNameMap(l)

}

// SetNameForLanguage sets the value of 'name' for the specified language
func (t *Mention) SetNameForLanguage(l string, v string) {
	t.raw.SetNameMap(l, v)

}

// LenSummary returns the number of values this property contains. Each index be used with HasSummary to determine if GetSummary is safe to call or if raw handling would be needed.%!(EXTRA string=summary)
func (t *Mention) LenSummary() (idx int) {
	return t.raw.SummaryLen()

}

// GetSummary attempts to get this 'summary' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetSummary(idx int) (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsSummaryString(idx) {
		k = t.raw.GetSummaryString(idx)
		if handled {
			r = Resolved
		}
	} else if t.raw.IsSummaryLangString(idx) {
		r = RawResolutionNeeded
	} else if t.raw.IsSummaryIRI(idx) {
		r = RawResolutionNeeded
	}
	return

}

// AddSummary appends the value for property 'summary'.
func (t *Mention) AddSummary(k string) {
	t.raw.AddSummaryString(k)

}

// RemoveSummary deletes the value from the specified index for property 'summary'.
func (t *Mention) RemoveSummary(idx int) {
	t.raw.RemoveSummaryString(idx)

}

// HasSummary returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasSummary(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsSummaryString(idx) {
		p = ConvenientPresence
	} else if t.raw.IsSummaryLangString(idx) {
		p = RawPresence
	} else if t.raw.IsSummaryIRI(idx) {
		p = RawPresence
	}
	return

}

// SummaryLanguages returns all languages for this property's language mapping, or nil if there are none.
func (t *Mention) SummaryLanguages() (l []string) {
	return t.raw.SummaryMapLanguages()

}

// GetSummaryMap retrieves the value of 'summary' for the specified language, or an empty string if it does not exist
func (t *Mention) GetSummaryForLanguage(l string) (v string) {
	return t.raw.GetSummaryMap(l)

}

// SetSummaryForLanguage sets the value of 'summary' for the specified language
func (t *Mention) SetSummaryForLanguage(l string, v string) {
	t.raw.SetSummaryMap(l, v)

}

// GetHreflang attempts to get this 'hreflang' property as a string. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetHreflang() (r Resolution, k string) {
	r = Unresolved
	handled := false
	if t.raw.IsHreflang() {
		k = t.raw.GetHreflang()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsHreflangIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasHreflang returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasHreflang() (p Presence) {
	p = NoPresence
	if t.raw.IsHreflang() {
		p = ConvenientPresence
	} else if t.raw.IsHreflangIRI() {
		p = RawPresence
	}
	return

}

// SetHreflang sets the value for property 'hreflang'.
func (t *Mention) SetHreflang(k string) {
	t.raw.SetHreflang(k)

}

// GetHeight attempts to get this 'height' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetHeight() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsHeight() {
		k = t.raw.GetHeight()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsHeightIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasHeight returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasHeight() (p Presence) {
	p = NoPresence
	if t.raw.IsHeight() {
		p = ConvenientPresence
	} else if t.raw.IsHeightIRI() {
		p = RawPresence
	}
	return

}

// SetHeight sets the value for property 'height'.
func (t *Mention) SetHeight(k int64) {
	t.raw.SetHeight(k)

}

// GetWidth attempts to get this 'width' property as a int64. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling.
func (t *Mention) GetWidth() (r Resolution, k int64) {
	r = Unresolved
	handled := false
	if t.raw.IsWidth() {
		k = t.raw.GetWidth()
		if handled {
			r = Resolved
		}
	} else if t.raw.IsWidthIRI() {
		r = RawResolutionNeeded
	}
	return

}

// HasWidth returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasWidth() (p Presence) {
	p = NoPresence
	if t.raw.IsWidth() {
		p = ConvenientPresence
	} else if t.raw.IsWidthIRI() {
		p = RawPresence
	}
	return

}

// SetWidth sets the value for property 'width'.
func (t *Mention) SetWidth(k int64) {
	t.raw.SetWidth(k)

}

// LenPreview returns the number of values this property contains. Each index be used with HasPreview to determine if ResolvePreview is safe to call or if raw handling would be needed.%!(EXTRA string=preview)
func (t *Mention) LenPreview() (idx int) {
	return t.raw.PreviewLen()

}

// ResolvePreview passes the actual concrete type to the resolver for handing property preview. It returns a Resolution appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) ResolvePreview(r *Resolver, idx int) (s Resolution, err error) {
	s = Unresolved
	handled := false
	if t.raw.IsPreviewObject(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewObject(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewLink(idx) {
		handled, err = r.dispatch(t.raw.GetPreviewLink(idx))
		if handled {
			s = Resolved
		}
	} else if t.raw.IsPreviewIRI(idx) {
		s = RawResolutionNeeded
	}
	return

}

// HasPreview returns a Presence appropriate for clients to determine whether it would be necessary to do raw handling, if desired.
func (t *Mention) HasPreview(idx int) (p Presence) {
	p = NoPresence
	if t.raw.IsPreviewObject(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewLink(idx) {
		p = ConvenientPresence
	} else if t.raw.IsPreviewIRI(idx) {
		p = RawPresence
	}
	return

}

// AddPreview adds an 'Object' typed value.
func (t *Mention) AddPreview(i vocab.ObjectType) {
	t.raw.AddPreviewObject(i)

}

// SetPreviewLink adds a 'Link' typed value.
func (t *Mention) SetPreviewLink(i vocab.LinkType) {
	t.raw.AddPreviewLink(i)

}
